<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HidroMet</title>
    
    <link rel="icon" type="image/png" href="images/favicon3.png">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* [Tu CSS de la Parte 1 no ha cambiado] */
        body { font-family: 'Roboto', sans-serif; color: #333; background-color: #f0f2f5; margin: 0; padding: 0; }
        .main-container { width: 95%; max-width: 1400px; margin: 30px auto; background: #ffffff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 20px; }
        h1 { color: #004d99; display: flex; font-weight: 300; letter-spacing: 1px; margin: 20px auto; font-size: 32px; justify-content: center; align-items: center; text-align: center; }
        .title-logo { height: 64px; margin-right: 2px; }
        .dashboard-layout { display: flex; flex-wrap: wrap; gap: 20px; min-height: 650px; }
        .map-panel { flex: 1.2; min-width: 500px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); border: 1px solid #e0e0e0; }
        .data-panel { flex: 1; min-width: 400px; background-color: #ffffff; border-radius: 8px; padding: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; border: 1px solid #e0e0e0; }
        #mapa { height: 100%; min-height: 500px; width: 100%; border: none; }
        #chartContainer { flex-grow: 1; width: 100%; display: block; padding: 0; box-sizing: border-box; position: relative; }
        .controls { margin-bottom: 10px; padding: 8px; background-color: #e9ecef; border-radius: 6px; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; width: 100%; box-sizing: border-box; }
        .info { padding: 6px 8px; font: 14px/16px 'Roboto', sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend i { width: 10px; height: 10px; float: left; margin-right: 8px; border-radius: 50%; border: 1px solid #000; }
        .hierarchy-selector-container { background-color: #f8f9fa; padding: 12px 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #dee2e6; display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; gap: 20px; }
        .selector-group { display: flex; align-items: center; gap: 10px; }
        .selector-group label { font-weight: 500; color: #495057; margin: 0; }
        #hierarchy-select, #variable-select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; min-width: 200px; width: auto; }
        .at-stats-selector { justify-content: center; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; max-width: 300px; margin: 5px auto 15px auto; padding: 8px 15px; gap: 8px; }
        .at-stats-selector label { font-weight: 400; font-size: 14px; }
        .at-stats-selector select { padding: 6px 10px; font-size: 14px; width: auto; min-width: 180px; }
        .basin-comparator-section { margin-top: 30px; padding: 20px; background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); }
        .basin-comparator-section h2 { color: #004d99; font-weight: 300; text-align: center; margin-top: 0; margin-bottom: 20px; }
        #basinChartContainer { width: 100%; min-height: 550px; } 
        #yearButtonsContainer, #basinYearButtonsContainer { display: flex; justify-content: center; overflow-x: auto; white-space: nowrap; gap: 6px; margin-bottom: 10px; padding: 6px; scrollbar-width: thin; }
        #yearButtonsContainer button, #basinYearButtonsContainer button { flex: 0 0 auto; background-color: #e9ecef; border: 1px solid #ccc; border-radius: 8px; padding: 5px 10px; cursor: pointer; transition: all 0.2s ease; font-size: 13px; }
        #yearButtonsContainer button:hover, #basinYearButtonsContainer button:hover, #yearButtonsContainer button.active, #basinYearButtonsContainer button.active { background-color: #007bff; color: white; }
        ::-webkit-scrollbar { height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #007bff; border-radius: 4px; }
        .methodology-box { margin-top: 25px; padding: 15px 20px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; font-size: 14px; color: #495057; }
        .methodology-box h4 { margin-top: 0; margin-bottom: 10px; color: #004d99; font-weight: 500; }
        .methodology-box p { margin-bottom: 10px; line-height: 1.6; }
        .methodology-box ul { margin-top: 5px; margin-bottom: 10px; padding-left: 20px; }
        .methodology-box li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>
            <img src="images/favicon3.png" alt="Logo HidroMet" class="title-logo">
            <b>HidroMet: </b> &nbsp; Explorador de Datos Hidrometeorol칩gicos Depurados de Chile
        </h1>
        
        <div class="hierarchy-selector-container">
            <div class="selector-group">
                <label for="hierarchy-select">Nivel de An치lisis:</label>
                <select id="hierarchy-select">
                    <option value="cuencas" selected>Cuencas</option>
                    <option value="subcuencas">Subcuencas</option>
                    <option value="subsubcuencas">Subsubcuencas</option>
                </select>
            </div>
            
            <div class="selector-group">
                <label for="variable-select">Variable:</label>
                <select id="variable-select">
                    <option value="ppt" selected>Precipitaci칩n</option>
                    <option value="sd">Altura de Nieve</option>
                    <option value="at">Temperatura</option> </select>
                </select>
            </div>
        </div>
        
        <div class="dashboard-layout">
            <div class="map-panel"><div id="mapa"></div></div>
            <div class="data-panel">
                <div class="controls">
                    <select id="station-select" onchange="displayTimeSeries(this.value)">
                        <option value="" selected disabled>--- Seleccione una Estaci칩n ---</option>
                    </select>
                </div>
                <div id="yearButtonsContainer"></div>
                <div id="chartContainer" class="plotly-graph-div">
                    <p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;">Seleccione una estaci칩n en el mapa o en el selector...</p>
                </div>
            </div>
        </div>

        <div class="basin-comparator-section">
            <h2 id="comparator-title">An치lisis Comparativo por Cuenca/Subcuenca</h2>
            <div id="basinYearButtonsContainer"></div>
            
            <div id="at-stats-selector-container" style="display: none;">
                <div class="selector-group at-stats-selector">
                    <label for="at-stats-select">Mostrar Extremo:</label>
                    <select id="at-stats-select">
                        <option value="max" selected>M치ximos Anuales</option>
                        <option value="min">M칤nimos Anuales</option>
                    </select>
                </div>
            </div>
            <div id="basinChartContainer" class="plotly-graph-div">
                <p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;">
                    Seleccione un nivel de an치lisis y haga clic en un pol칤gono del mapa para comparar.
                </p>
            </div>

            <div class="methodology-box" id="methodology-ppt">
                <h4>Nota Metodol칩gica (Precipitaci칩n) 游닇</h4>
                 <p>
                    <strong>Acumulado Mensual:</strong> Un mes se muestra si contiene > <strong>70%</strong> de d칤as con datos.
                </p>
                <p>
                    <strong>Acumulado Anual:</strong> Un a침o es v치lido si tiene datos para <strong>todos</strong> los meses entre <strong>Mayo y Octubre</strong>, y cada uno de esos meses cumple la regla de validez del 70%.
                </p>
            </div>
            
            <div class="methodology-box" id="methodology-sd" style="display:none;">
                <h4>Nota Metodol칩gica (Altura de Nieve) 游닇</h4>
                <p>
                    <strong>Mediana Mensual:</strong> Un mes se muestra si contiene > <strong>70%</strong> de d칤as con datos.
                </p>
                 <p>
                    <strong>Mediana Anual (May-Oct):</strong> Un a침o es v치lido si tiene datos para <strong>todos</strong> los meses entre <strong>Mayo y Octubre</strong>, y cada uno de esos meses cumple la regla validez del 70%. El valor mostrado es la <strong>mediana</strong> de todos los datos diarios de ese per칤odo (May-01 a Oct-31).
                </p>
            </div>

            <div class="methodology-box" id="methodology-at" style="display:none;">
                <h4>Nota Metodol칩gica (Temperatura) 游닇</h4>
                 <p>
                    <strong>Mediana Mensual:</strong> Un mes se muestra si contiene > <strong>70%</strong> de d칤as con datos.
                </p>
                 <p>
                    <strong>Mediana Anual (May-Oct):</strong> Un a침o es v치lido si tiene datos para <strong>todos</strong> los meses entre <strong>Mayo y Octubre</strong>, y cada uno de esos meses cumple la regla de validez del 70%. El valor mostrado es la <strong>mediana</strong> de todos los datos diarios de ese per칤odo (May-01 a Oct-31).
                </p>
            </div>

        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // --- CONFIGURACI칍N Y VARIABLES GLOBALES ---
        Plotly.setPlotConfig({locale: 'es'});
        const DATA_STATIC_BASE_URL = 'data_static'; 
        const ZOOM_THRESHOLD = 10;
        let mapa = null;
        let layerControl = null;
        let estacionesLayer = null; 
        let stationNameMap = {}; 
        let cuencasLayer = null;
        let subcuencasLayer = null;
        let subsubcuencasLayer = null;
        let highlightedFeature = null;
        let currentBasinFullData = null;
        let stationColorMap = {};
        let globalGeojsonData = null; 

        let currentVariable = 'ppt'; 
        let currentHierarchy = 'cuencas'; 

        const HIGH_CONTRAST_PALETTE = ['#332288', '#117733', '#44AA99', '#88CCEE', '#DDCC77', '#CC6677', '#AA4499', '#882255', '#E69F00', '#56B4E9', '#009E73', '#F0E442'];
        
        // --- CORRECCI칍N: Configuraci칩n de UI alineada con el backend ---
        const VARIABLE_UI_CONFIG = {
            'ppt': { 
                name: "Precipitaci칩n", 
                unit: "mm", 
                data_col: "Precipitacion_mm", // Coincide con backend
                agg_monthly_desc: "Acumulado Mensual", 
                annual_analysis_type: 'ppt_annual' // Tipo de an치lisis anual
            },
            'sd': { 
                name: "Altura de Nieve", 
                unit: "cm", 
                data_col: "Altura_de_Nieve_cm", // Coincide con backend
                agg_monthly_desc: "Mediana Mensual", // CAMBIADO de Promedio a Mediana
                annual_analysis_type: 'sd_median' // CAMBIADO de 'sd_max' a 'sd_median'
            },
            'at': { 
                name: "Temperatura", 
                unit: "춿C", 
                data_col: "Temperatura_춿C", // Coincide con backend
                agg_monthly_desc: "Mediana Mensual", // CAMBIADO de Promedio a Mediana
                annual_analysis_type: 'at_median' // CAMBIADO de 'at_stats' a 'at_median'
            }
        };
        // --- FIN CORRECCI칍N ---


        const HIERARCHY_CONFIG = {
            'cuencas': { id_property: 'COD_CUEN', name_property: 'NOM_CUEN', name: 'Cuenca' },
            'subcuencas': { id_property: 'COD_SUBC', name_property: 'NOM_SUBC', name: 'Subcuenca' },
            'subsubcuencas': { id_property: 'COD_SSUBC', name_property: 'NOM_SSUBC', name: 'Subsubcuenca' }
        };

        const FUENTES_MAP = { 'DGA': '#007bff', 'CEAZAMET': '#28a745', 'CIEP': '#ffc107', 'CECS': '#dc3545', 'DMC': '#6f42c1', 'CR2': '#fd7e14', 'Otro': '#6c757d' };
        
        window.onload = () => {
            inicializarMapa();
            cargarDatosGeoespaciales();
            switchHierarchyLayer('cuencas');

            document.getElementById('hierarchy-select').addEventListener('change', (e) => switchHierarchyLayer(e.target.value));
            document.getElementById('variable-select').addEventListener('change', (e) => {
                currentVariable = e.target.value; 
                onVariableChange(); 
            });
        };

        // --- (Funci칩n onVariableChange SIN CAMBIOS, ya era correcta) ---
        function onVariableChange() {
            console.log(`Cambiando a variable: ${currentVariable}`);
            
            // 1. Limpia los gr치ficos y RESTAURA los mensajes iniciales
            Plotly.purge('chartContainer');
            const chartStatus = document.getElementById('chartStatus');
            if (!chartStatus) {
                document.getElementById('chartContainer').innerHTML = '<p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;"></p>';
            }
            document.getElementById('chartStatus').innerText = 'Seleccione una estaci칩n en el mapa o en el selector...';
            document.getElementById('chartStatus').style.display = 'block'; 
            document.getElementById('yearButtonsContainer').innerHTML = ''; 

            Plotly.purge('basinChartContainer');
            const basinChartStatus = document.getElementById('basinChartStatus');
            if (!basinChartStatus) {
                 document.getElementById('basinChartContainer').innerHTML = '<p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;"></p>';
            }
            document.getElementById('basinChartStatus').innerText = 'Seleccione un pol칤gono en el mapa para comparar.';
            document.getElementById('basinChartStatus').style.display = 'block'; 
            document.getElementById('basinYearButtonsContainer').innerHTML = ''; 
            document.getElementById('comparator-title').innerText = 'An치lisis Comparativo por Cuenca/Subcuenca'; 
            
            // 2. Recarga la capa de pol칤gonos
            switchHierarchyLayer(currentHierarchy); 

            // 3. Filtra marcadores y dropdown
            filterStationsOnMap();
            filterStationDropdown(); 

            // 4. Actualiza la nota metodol칩gica
            updateMethodologyBox();
            
            // 5. Oculta el selector de AT (ya era correcto)
            document.getElementById('at-stats-selector-container').style.display = 'none';
            
            console.log("Paneles reseteados por cambio de variable.");
        }

        // --- (Funciones filterStationsOnMap y filterStationDropdown SIN CAMBIOS) ---
        function filterStationsOnMap() {
             if (!estacionesLayer) return;
             estacionesLayer.eachLayer(layer => {
                 const props = layer.feature.properties;
                 const variables = (props.variables_disponibles || "").split('|'); 
                 
                 if (!variables.includes(currentVariable.toUpperCase())) {
                     layer.setStyle({ fillColor: '#999', color: '#999', weight: 0.5, fillOpacity: 0.3 });
                 } else {
                     layer.setStyle({ 
                         fillColor: getColorByFuente(props.fuente), 
                         color: "#000", 
                         weight: 1, 
                         fillOpacity: 0.8 
                     });
                 }
             });
        }
        function filterStationDropdown() {
             if (!globalGeojsonData) return; 

            const stationSelect = document.getElementById('station-select');
            const previouslySelected = stationSelect.value; 
            stationSelect.value = ""; 

            let firstVisibleStationCode = null; 

            for (const optgroup of stationSelect.querySelectorAll('optgroup')) {
                 let hasVisibleOptions = false;
                 for (const option of optgroup.querySelectorAll('option')) {
                     const stationCode = option.value;
                     const feature = globalGeojsonData.features.find(f => f.properties.code_internal === stationCode);
                     
                     if (feature) {
                         const variables = (feature.properties.variables_disponibles || "").split('|');
                         if (variables.includes(currentVariable.toUpperCase())) {
                             option.style.display = 'block'; 
                             hasVisibleOptions = true;
                             if (!firstVisibleStationCode) {
                                 firstVisibleStationCode = stationCode; 
                             }
                         } else {
                             option.style.display = 'none'; 
                         }
                     } else {
                         option.style.display = 'none';
                     }
                 }
                 optgroup.style.display = hasVisibleOptions ? 'block' : 'none';
            }

            const optionToReselect = stationSelect.querySelector(`option[value="${previouslySelected}"]`);
            if (optionToReselect && optionToReselect.style.display !== 'none') {
                 stationSelect.value = previouslySelected;
            } else {
                 stationSelect.value = ""; 
            }
        }
        
        // --- (Funci칩n updateMethodologyBox SIN CAMBIOS, ya era correcta) ---
        function updateMethodologyBox() {
            document.getElementById('methodology-ppt').style.display = 'none';
            document.getElementById('methodology-sd').style.display = 'none';
            document.getElementById('methodology-at').style.display = 'none'; 

            if (currentVariable === 'ppt') {
                document.getElementById('methodology-ppt').style.display = 'block';
            } else if (currentVariable === 'sd') {
                document.getElementById('methodology-sd').style.display = 'block';
            } else if (currentVariable === 'at') { 
                document.getElementById('methodology-at').style.display = 'block';
            }
        }
        
        // --- (Funci칩n inicializarMapa SIN CAMBIOS) ---
        function inicializarMapa() {
             mapa = L.map('mapa').setView([-33.4489, -70.6693], 5);
             mapa.createPane('cuencasPane');
             mapa.getPane('cuencasPane').style.zIndex = 350;

             const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                 attribution: '춸 OpenStreetMap contributors' 
             }).addTo(mapa);
             const satelite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                 attribution: '춸 Esri' 
             });
             const topografico = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                 attribution: '춸 Esri'
             });

             const baseMaps = {"Calles": osm, "Satelital": satelite, "Topogr치fico": topografico };
             layerControl = L.control.layers(baseMaps, {}).addTo(mapa);

             const legend = L.control({position: 'bottomright'});
             legend.onAdd = function () {
                 const div = L.DomUtil.create('div', 'info legend');
                 let legendHtml = '<b>Fuentes</b>';
                 const items = Object.keys(FUENTES_MAP).map(key => `<i style="background:${FUENTES_MAP[key]}"></i> ${key}`);
                 legendHtml += `<div style="margin-top: 4px;">${items.join('<br>')}</div>`;
                 div.innerHTML = legendHtml;
                 return div;
             };
             legend.addTo(mapa);
             
             mapa.on('zoomend', updateLayerInteractivity);
        }

        // --- (Funci칩n getColorByFuente SIN CAMBIOS) ---
        function getColorByFuente(fuente) {
             fuente = (fuente || '').toUpperCase().replace(/_NERC/g, ''); 
            return FUENTES_MAP[fuente] || '#6c757d';
        }

        async function cargarDatosGeoespaciales() {
            try {
                // --- CORRECCI칍N 1 (Cache-Busting): A침adido `?v=${Date.now()}` ---
                const cacheBuster = `?v=${Date.now()}`;
                const [nameResponse, geoResponse] = await Promise.all([
                    fetch(`${DATA_STATIC_BASE_URL}/station_names.json${cacheBuster}`),
                    fetch(`${DATA_STATIC_BASE_URL}/estaciones.geojson${cacheBuster}`) 
                ]);
                // --- FIN CORRECCI칍N ---
                
                if (!nameResponse.ok) {
                    console.error("춰ERROR! No se pudo cargar station_names.json. Status:", nameResponse.status);
                    stationNameMap = {}; 
                } else {
                    try {
                        stationNameMap = await nameResponse.json();
                        console.log("station_names.json cargado OK.");
                    } catch (e) {
                         console.error("Error al parsear station_names.json:", e);
                         stationNameMap = {};
                    }
                }

                if (!geoResponse.ok) {
                    console.error("춰ERROR CR칈TICO! No se encontr칩 'estaciones.geojson'. Status:", geoResponse.status);
                    console.error("Por favor, ejecuta el script de backend (exportar_datos_estaticos.py) y aseg칰rate de que no haya errores.");
                    document.body.innerHTML = "<h1 style='color:red;'>Error Cr칤tico: Falta estaciones.geojson. Revisa la consola (F12) y ejecuta el backend.</h1>"; 
                    return; 
                }
                globalGeojsonData = await geoResponse.json(); 
                console.log("estaciones.geojson cargado OK.");
                
                if (estacionesLayer) { 
                    mapa.removeLayer(estacionesLayer); 
                    layerControl.removeLayer(estacionesLayer); 
                }

                populateStationDropdown(globalGeojsonData.features);

                estacionesLayer = L.geoJSON(globalGeojsonData, {
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, {radius: 6, fillColor: getColorByFuente(feature.properties.fuente), color: "#000", weight: 1, fillOpacity: 0.8}),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        if (props && props.code_internal) {
                            
                            const variables = props.variables_disponibles || ""; 
                            const vars_display = variables.replace(/\|/g, ', ') || 'N/A'; 

                            const html = `
                                <div style="line-height: 1.5;">
                                    <h4 style="margin: 0 0 5px 0; color:${getColorByFuente(props.fuente)};">${props.name || 'N/A'}</h4>
                                    <b>C칩digo:</b> ${props.code_internal}<br>
                                    <b>Elevaci칩n:</b> ${props.elevation || 'N/A'} m.s.n.m.<br>
                                    <b>Fuente:</b> ${props.fuente || 'N/A'}<br>
                                    <b>Variables:</b> ${vars_display}
                                </div>`;
                            layer.bindPopup(html);
                        }
                    }
                }).addTo(mapa);
                
                layerControl.addOverlay(estacionesLayer, "Estaciones");
                const bounds = estacionesLayer.getBounds();
                if (bounds.isValid()) mapa.fitBounds(bounds.pad(0.1));

                updateLayerInteractivity();
                filterStationsOnMap(); 
                filterStationDropdown(); 
            } catch (error) { 
                console.error("Error MUY GRAVE al cargar datos geoespaciales:", error); 
                document.body.innerHTML = `<h1 style='color:red;'>Error Inesperado: ${error.message}. Revisa la consola (F12).</h1>`;
            }
        }

        // --- (Funci칩n populateStationDropdown SIN CAMBIOS) ---
        function populateStationDropdown(features) {
             const stationSelect = document.getElementById('station-select');
            stationSelect.innerHTML = '<option value="" selected disabled>--- Seleccione una Estaci칩n ---</option>';
            
            const basinData = {};
            features.forEach(feature => {
                const props = feature.properties;
                if (!props.code_internal || !props.basin) return;
                const basinName = props.basin.replace(/\s*\([^)]*\)$/, '');
                const basinCode = String(props.code_internal).substring(0, 3);
                if (!basinData[basinName]) {
                    basinData[basinName] = { name: basinName, code: basinCode, stations: [] };
                }
                basinData[basinName].stations.push(props);
            });

            const sortedBasins = Object.values(basinData).sort((a, b) => parseInt(a.code, 10) - parseInt(b.code, 10));
            sortedBasins.forEach(basin => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${basin.name} (${basin.code})`;
                
                basin.stations.sort((a, b) => {
                    const codeA = parseInt(a.code_internal.replace( /^\D+/g, ''), 10) || a.code_internal;
                    const codeB = parseInt(b.code_internal.replace( /^\D+/g, ''), 10) || b.code_internal;
                    if (isFinite(codeA) && isFinite(codeB)) {
                        return codeA - codeB;
                    }
                    return a.code_internal.localeCompare(b.code_internal);
                });

                basin.stations.forEach(props => {
                    const option = new Option(`${props.name || 'N/A'} (${props.code_internal})`, props.code_internal);
                    optgroup.appendChild(option);
                });
                stationSelect.appendChild(optgroup);
            });
        }

        async function displayTimeSeries(stationCode) {
            if (!stationCode) return;
            const chartDiv = document.getElementById('chartContainer');
            Plotly.purge(chartDiv); 
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando serie temporal para ${stationCode}...</p>`; 
            document.getElementById('station-select').value = stationCode;
            
            // --- CORRECCI칍N 2 (Cache-Busting): A침adido `?v=${Date.now()}` ---
            const csvUrl = `${DATA_STATIC_BASE_URL}/${stationCode}_${currentVariable}.csv?v=${Date.now()}`;
            console.log("Intentando cargar CSV:", csvUrl); 

            try {
                const response = await fetch(csvUrl);
                
                if (!response.ok) {
                    console.error(`Error ${response.status} al cargar ${csvUrl}`); 
                    if (response.status === 404) {
                        const config = VARIABLE_UI_CONFIG[currentVariable];
                        throw new Error(`Datos de '${config.name}' no disponibles para la estaci칩n ${stationCode}.`);
                    }
                    throw new Error(`No se pudo cargar el CSV ${stationCode} (c칩digo ${response.status})`);
                }
                console.log(`CSV ${csvUrl} cargado OK.`); 

                const csvText = await response.text();
                const parseResult = Papa.parse(csvText, {header: true, dynamicTyping: true, skipEmptyLines: true});
                const data = parseResult.data;
                
                if (parseResult.errors.length > 0) { console.warn(`Errores de PapaParse para ${csvUrl}:`, parseResult.errors); }
                if (data.length === 0) { console.warn(`PapaParse no encontr칩 datos en ${csvUrl}.`); throw new Error(`No se encontraron datos en el archivo CSV para ${stationCode}.`); }
                 
                const stationName = stationNameMap[stationCode] || stationCode; 
                 if (!stationNameMap[stationCode]) { console.warn(`No se encontr칩 el nombre para ${stationCode}.`); }

                const years = [...new Set(data.map(d => parseInt(d.Fecha.substring(0, 4), 10)))].sort((a,b) => a-b); 
                const container = document.getElementById("yearButtonsContainer");
                container.innerHTML = "";

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderPlot(data, stationName, null, allBtn);
                container.appendChild(allBtn);

                years.forEach(y => {
                    const btn = document.createElement("button");
                    btn.textContent = y;
                    btn.onclick = () => renderPlot(data.filter(d => parseInt(d.Fecha.substring(0, 4), 10) === y), stationName, y, btn);
                    container.appendChild(btn);
                });
                renderPlot(data, stationName, null, allBtn);
            } catch (error) { 
                console.error("Error en displayTimeSeries:", error); 
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; 
            }
        }

        // --- (Funci칩n renderPlot SIN CAMBIOS, ya era correcta) ---
        function renderPlot(data, stationName, year, activeBtn) {
            document.querySelectorAll("#yearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");
            
            const config = VARIABLE_UI_CONFIG[currentVariable];
            const dataColumnName = config.data_col; 
            
            if (data.length > 0 && !(dataColumnName in data[0])) {
                 console.error(`Columna '${dataColumnName}' no encontrada. Disponibles:`, Object.keys(data[0]));
                 document.getElementById('chartContainer').innerHTML = `<p style="text-align:center;color:red;padding:50px;">Error: Columna '${dataColumnName}' no encontrada.</p>`;
                 return; 
            }

            let trace = {
                x: data.map(d => d.Fecha), 
                y: data.map(d => {
                    let v = d[dataColumnName]; 
                    if(typeof v === 'string') v = parseFloat(v.trim().replace(',', '.')); 
                    return isFinite(v) ? v : null; 
                })
            };

            // Define tipo y color seg칰n la variable
            if (currentVariable === 'sd') { // Nieve
                 trace.type = 'scatter';
                 trace.connectgaps = false;
                 trace.mode = 'lines+markers'; 
                 trace.line = { color: "#88CCEE" }; // Azul claro (cyan)
                 trace.marker = { color: "#88CCEE", size: 4 }; 
            } else if (currentVariable === 'at') { // Temperatura
                 trace.type = 'scatter';
                 trace.connectgaps = false;
                 trace.mode = 'lines+markers'; 
                 trace.line = { color: "#CC6677" }; // Rojo coral
                 trace.marker = { color: "#CC6677", size: 4 };
            } else { // Precipitaci칩n (default)
                 trace.type = 'bar';
                 trace.marker = { color: "#007bff" }; // Azul
            }
            
            const layout = {
                title: `${config.name} diaria - ${stationName}${year ? ` (${year})` : ""}`,
                margin: { l: 50, r: 50, t: 60, b: 50 }, 
                xaxis: { title: "Fecha", rangeslider: {visible: false} },
                yaxis: { title: `${config.name} (${config.unit})` }, 
                hovermode: "x unified", 
            };

            Plotly.react("chartContainer", [trace], layout, {responsive: true});
             console.log(`Gr치fico renderizado para ${stationName} (${year || 'Completo'}) - Tipo: ${trace.type}`); 
        }

        async function switchHierarchyLayer(hierarchyKey) {
            currentHierarchy = hierarchyKey; 
            console.log(`Cambiando a jerarqu칤a: ${hierarchyKey}`); 
            
            let removedCuencas = false, removedSub = false, removedSubSub = false;
            if (cuencasLayer) { try { mapa.removeLayer(cuencasLayer); layerControl.removeLayer(cuencasLayer); removedCuencas = true; } catch(e) { console.warn("Error quitando cuencasLayer:", e); } }
            if (subcuencasLayer) { try { mapa.removeLayer(subcuencasLayer); layerControl.removeLayer(subcuencasLayer); removedSub = true; } catch(e) { console.warn("Error quitando subcuencasLayer:", e); } }
            if (subsubcuencasLayer) { try { mapa.removeLayer(subsubcuencasLayer); layerControl.removeLayer(subsubcuencasLayer); removedSubSub = true; } catch(e) { console.warn("Error quitando subsubcuencasLayer:", e); } }
            console.log(`Capas antiguas removidas: Cuencas=${removedCuencas}, Sub=${removedSub}, SubSub=${removedSubSub}`);
            
            highlightedFeature = null; 

            const config = HIERARCHY_CONFIG[hierarchyKey];
            if (!config) return;

            // --- CORRECCI칍N 3 (Cache-Busting): A침adido `?v=${Date.now()}` ---
            const url = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${currentVariable}.geojson?v=${Date.now()}`;
            console.log("Intentando cargar GeoJSON de jerarqu칤a:", url); 

            try {
                const response = await fetch(url);

                if (!response.ok) {
                    console.error(`No se pudo cargar ${url}. Status: ${response.status}. 쮼jecutaste el backend correctamente?`);
                    throw new Error(`No se pudo cargar ${url}.`);
                }
                console.log(`GeoJSON ${url} cargado OK.`); 

                const geojsonData = await response.json();
                const style = { color: "#1a5276", weight: 1.5, opacity: 0.6, fillOpacity: 0.2 };
                const highlightStyle = { weight: 3, color: '#e74c3c', fillOpacity: 0.4 };

                let newLayer = L.geoJSON(geojsonData, { 
                    style: style,
                    pane: 'cuencasPane',
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const nEstaciones = props.n_estaciones || 0; 
                        const popupContent = `
                            <div style="line-height: 1.5;">
                                <h4 style="margin: 0 0 5px 0; color:#1a5276;">${config.name}: ${props[config.name_property] || 'N/A'}</h4>
                                <b>C칩digo:</b> ${props[config.id_property]}<br>
                                <b>N춿 de estaciones:</b> ${nEstaciones}
                            </div>`;
                        layer.bindPopup(popupContent);
                        layer.on({
                            click: e => {
                                console.log(`Clic en pol칤gono ${props[config.id_property]}. HighlightedFeature:`, highlightedFeature ? 'existe' : 'null'); 
                                if (highlightedFeature) {
                                    try {
                                         newLayer.resetStyle(highlightedFeature); 
                                         console.log("Estilo reseteado para pol칤gono anterior."); 
                                    } catch(err) {
                                        console.warn("No se pudo resetear el estilo del pol칤gono anterior (puede ser normal si cambi칩 la capa):", err);
                                    }
                                }
                                highlightedFeature = e.target; 
                                e.target.setStyle(highlightStyle);
                                console.log("Nuevo pol칤gono resaltado:", highlightedFeature); 
                                
                                displayBasinChart(props[config.id_property], props[config.name_property] || '', hierarchyKey);
                                
                                const comparatorSection = document.querySelector('.basin-comparator-section');
                                comparatorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        });
                    }
                }).addTo(mapa);
                
                let layerName = "Capa";
                if (hierarchyKey === 'cuencas') { cuencasLayer = newLayer; layerName = "Cuencas"; }
                else if (hierarchyKey === 'subcuencas') { subcuencasLayer = newLayer; layerName = "Subcuencas"; }
                else { subsubcuencasLayer = newLayer; layerName = "Subsubcuencas"; }
                
                layerControl.addOverlay(newLayer, layerName);
                updateLayerInteractivity();
                console.log(`Capa ${layerName} (${currentVariable}) a침adida al mapa.`); 

            } catch (error) { console.error(`Error FATAL en switchHierarchyLayer (${hierarchyKey}, ${currentVariable}):`, error); }
        }

        // --- (Funci칩n updateLayerInteractivity SIN CAMBIOS) ---
        function updateLayerInteractivity() {
             if (!mapa) return;
            const zoom = mapa.getZoom();

            let activeHierarchyLayer;
            if (currentHierarchy === 'cuencas') activeHierarchyLayer = cuencasLayer;
            else if (currentHierarchy === 'subcuencas') activeHierarchyLayer = subcuencasLayer;
            else activeHierarchyLayer = subsubcuencasLayer;
            if (activeHierarchyLayer) {
                 activeHierarchyLayer.eachLayer(layer => {
                     if (zoom < ZOOM_THRESHOLD) {
                         if (!layer.listens('mouseover')) {
                             layer.on({
                                 mouseover: function (e) { this.openPopup(e.latlng); },
                                 mouseout: function () { this.closePopup(); },
                                 mousemove: function (e) { if (this.isPopupOpen()) this.getPopup().setLatLng(e.latlng); }
                             });
                         }
                     } else {
                         layer.off('mouseover mouseout mousemove');
                         layer.closePopup();
                     }
                 });
            }

            if (estacionesLayer) {
                 estacionesLayer.eachLayer(layer => {
                     const props = layer.feature.properties;
                     const variables = (props.variables_disponibles || "").split('|');
                     const hasData = variables.includes(currentVariable.toUpperCase());

                     if (zoom < ZOOM_THRESHOLD) {
                         layer.setRadius(3);
                         layer.off('mouseover mouseout click');
                     } else {
                         layer.setRadius(6);
                         if (hasData) {
                             if (!layer.listens('click')) { 
                                 layer.on({
                                     mouseover: function () { this.openPopup(); },
                                     mouseout: function () { this.closePopup(); },
                                     click: () => { displayTimeSeries(props.code_internal); } 
                                 });
                             }
                         } else {
                             if (layer.listens('click')) { 
                                 layer.off('mouseover mouseout click');
                             }
                         }
                     }
                 });
            } else {
                 console.warn("updateLayerInteractivity: estacionesLayer no existe todav칤a."); 
            }
        }
        
        async function displayBasinChart(featureId, featureName, hierarchyKey) {
            const chartDiv = document.getElementById('basinChartContainer');
            const buttonContainer = document.getElementById('basinYearButtonsContainer');
            Plotly.purge(chartDiv); 
            buttonContainer.innerHTML = '';
            document.getElementById('at-stats-selector-container').style.display = 'none'; 

            const hierarchyConfig = HIERARCHY_CONFIG[hierarchyKey];
            const locationTitle = `${hierarchyConfig.name} ${featureName} (${featureId})`;
            document.getElementById('comparator-title').innerText = `An치lisis Comparativo para ${locationTitle}`;
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de ${locationTitle}...</p>`;

            // --- CORRECCI칍N 4 (Cache-Busting): A침adido `?v=${Date.now()}` ---
            const jsonUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_${currentVariable}.json?v=${Date.now()}`;
            console.log("Intentando cargar JSON de cuenca:", jsonUrl); 

            try {
                const response = await fetch(jsonUrl);
                
                if (!response.ok) {
                    console.error(`Error ${response.status} al cargar ${jsonUrl}`); 
                    throw new Error(`No se encontraron datos para ${locationTitle} (Variable: ${currentVariable}).`);
                 }
                 
                currentBasinFullData = await response.json(); 

                if (!currentBasinFullData || typeof currentBasinFullData !== 'object' || Object.keys(currentBasinFullData).length === 0) {
                    console.warn(`Los datos JSON para ${featureId} (${currentVariable}) est치n vac칤os o son inv치lidos.`);
                    throw new Error(`No hay datos v치lidos para mostrar para ${locationTitle} (Variable: ${currentVariable}).`);
                }
                console.log(`JSON ${jsonUrl} cargado OK y contiene datos.`); 

                stationColorMap = {};
                Object.keys(currentBasinFullData).forEach((stationCode, i) => { 
                    stationColorMap[stationCode] = HIGH_CONTRAST_PALETTE[i % HIGH_CONTRAST_PALETTE.length];
                });
                
                const allDates = Object.values(currentBasinFullData).flatMap(s => s.dates);
                if (allDates.length === 0) {
                    console.warn(`No se encontraron fechas en los datos JSON para ${featureId}.`);
                    renderBasinPlot({}, null, null); 
                    return;
                }
                const years = [...new Set(allDates.map(d => parseInt(d.substring(0, 4), 10)))].sort((a,b)=>a-b);

                // --- Botones de A침o ---
                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderBasinPlot(currentBasinFullData, null, allBtn);
                buttonContainer.appendChild(allBtn);

                years.forEach(year => {
                    const btn = document.createElement("button");
                    btn.textContent = year;
                    btn.onclick = () => { /* ... (l칩gica de filtro sin cambios) ... */ 
                        const filteredData = {};
                        for (const stationCode in currentBasinFullData) {
                            const station = currentBasinFullData[stationCode];
                            const filteredDates = [], filteredValues = [];
                            let hasNonNullData = false;
                            station.dates.forEach((date, i) => {
                                if (parseInt(date.substring(0, 4), 10) === year) {
                                    filteredDates.push(date); filteredValues.push(station.values[i]);
                                    if (station.values[i] !== null) hasNonNullData = true;
                                }
                            });
                            if (hasNonNullData) { filteredData[stationCode] = { ...station, dates: filteredDates, values: filteredValues }; }
                        }
                        renderBasinPlot(filteredData, year, btn);
                    };
                    buttonContainer.appendChild(btn);
                });
                // --- Fin Botones de A침o ---

                // --- CORRECCI칍N: L칩gica de botones anuales alineada con el backend ---
                const annualConfig = VARIABLE_UI_CONFIG[currentVariable];
                const analysisType = annualConfig.annual_analysis_type;

                if (analysisType) { // Si hay alg칰n tipo de an치lisis anual definido
                    const annualBtn = document.createElement("button");
                    let buttonText = "An치lisis Anual"; 
                    let clickHandler = null;

                    if (analysisType === 'ppt_annual') {
                        buttonText = "Acumulaci칩n Anual";
                        // Llama a la funci칩n original de PPT, que ya era correcta
                        clickHandler = () => renderBasinAnnualPlot(featureId, hierarchyKey, annualBtn);
                    } else if (analysisType === 'sd_median') {
                        buttonText = "Mediana Anual (May-Oct)";
                        // Llama a la funci칩n que vamos a CORREGIR
                        clickHandler = () => renderBasinAnnualMedianPlot_SD(featureId, hierarchyKey, annualBtn);
                    } else if (analysisType === 'at_median') {
                        buttonText = "Mediana Anual (May-Oct)";
                        // Llama a la funci칩n que vamos a CORREGIR
                        clickHandler = () => renderBasinAnnualMedianPlot_AT(featureId, hierarchyKey, annualBtn);
                    }
                    
                    if(clickHandler) {
                        annualBtn.textContent = buttonText;
                        annualBtn.onclick = clickHandler;
                        buttonContainer.appendChild(annualBtn);
                    }
                }
                // --- FIN CORRECCI칍N ---
                
                renderBasinPlot(currentBasinFullData, null, allBtn); // Muestra el gr치fico mensual por defecto
            } catch (error) {
                console.error("Error en displayBasinChart:", error); 
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
                currentBasinFullData = null;
            }
        }
        
        // --- (Funci칩n renderBasinPlot SIN CAMBIOS, ya era correcta) ---
        function renderBasinPlot(dataToPlot, year, activeBtn) {
            document.getElementById('at-stats-selector-container').style.display = 'none'; 
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            if (Object.keys(dataToPlot).length === 0) {
                console.log("renderBasinPlot: No hay datos para graficar.");
                Plotly.newPlot('basinChartContainer', [], {title: `No hay datos disponibles${year ? ` (${year})` : ''}`});
                return;
            }

            const sortedStations = Object.entries(dataToPlot).sort(([, stationA], [, stationB]) => {
                const elevA = stationA.elevation === null ? Infinity : stationA.elevation;
                const elevB = stationB.elevation === null ? Infinity : stationB.elevation;

                if (currentVariable === 'at') {
                    return elevA - elevB; 
                } else {
                    return elevB - elevA;
                }
            });

            const config = VARIABLE_UI_CONFIG[currentVariable];
            const yAxisTitle = `${config.name} (${config.unit})`;
            const plotTitle = `${config.agg_monthly_desc} de ${config.name}${year ? ` (${year})` : ''}`;
            const hoverUnit = config.unit;

            const traces = sortedStations.map(([stationCode, station]) => {
                const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                return { 
                    x: station.dates, 
                    y: station.values, 
                    mode: 'lines+markers', 
                    name: `${station.name} (${elevationText})`, 
                    type: 'scatter', connectgaps: false,
                    line: { color: stationColorMap[stationCode] || '#ccc' }, 
                    marker: { color: stationColorMap[stationCode] || '#ccc'},
                    hovertemplate: `<b>${station.name}</b><br>%{x|%B de %Y}<br>${config.name}: %{y:.1f} ${hoverUnit}<extra></extra>`, 
                };
            });

            const xAxisConfig = { title: 'Fecha' };
            if (year) {
                xAxisConfig.range = [`${year}-01-01`, `${year}-12-31`];
                xAxisConfig.tickformat = '%B';
            }

            const layout = {
                title: plotTitle, 
                xaxis: xAxisConfig,
                yaxis: { title: yAxisTitle }, 
                hovermode: 'closest',
                showlegend: true,
                legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                margin: { r: 250 }
            };
            
            Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
             console.log(`Gr치fico de cuenca renderizado (${year || 'Completo'})`); 
        }

        async function renderBasinAnnualPlot(featureId, hierarchyKey, activeBtn) {
            document.getElementById('at-stats-selector-container').style.display = 'none'; 
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de acumulaci칩n anual...</p>`;

            // --- CORRECCI칍N 5 (Cache-Busting): A침adido `?v=${Date.now()}` ---
            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_${currentVariable}_annual.json?v=${Date.now()}`; // _ppt_annual.json
            console.log("Intentando cargar JSON anual PPT:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de acumulaci칩n anual.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualPlot: No hay datos anuales PPT."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos anuales disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const config = VARIABLE_UI_CONFIG[currentVariable]; // Ser치 PPT aqu칤
                const yAxisTitle = `Acumulado Anual (${config.unit})`;
                const hoverUnit = config.unit;
                const hoverName = config.name;

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years, y: station.values, name: `${station.name} (${elevationText})`,
                        type: 'scatter', mode: 'lines+markers', connectgaps: false,
                        line: { color: stationColorMap[stationCode] || '#333' }, marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A침o: %{x}<br>${hoverName}: %{y:.1f} ${hoverUnit}<extra></extra>`,
                    };
                });

                const layout = {
                    title: 'Precipitaci칩n Acumulada Anual (A침os V치lidos May-Oct)', // --- CORRECCI칍N --- T칤tulo actualizado
                    xaxis: { title: 'A침o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest',
                    legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log("Gr치fico anual PPT renderizado."); 

            } catch (error) { console.error("Error en renderBasinAnnualPlot:", error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }

        // --- CORRECCI칍N: Funci칩n REESCRITA para SD (Mediana) ---
        async function renderBasinAnnualMedianPlot_SD(featureId, hierarchyKey, activeBtn) {
            document.getElementById('at-stats-selector-container').style.display = 'none'; 
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando mediana anual de nieve (May-Oct)...</p>`;

            // Construye la URL del archivo CORRECTO del backend
            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_sd_annual_median.json?v=${Date.now()}`; 
            console.log("Intentando cargar JSON anual SD Median:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de mediana anual de nieve.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualMedianPlot_SD: No hay datos."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos de mediana anual de nieve disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const config = VARIABLE_UI_CONFIG['sd']; // Usa config de SD
                const yAxisTitle = `Mediana Anual (May-Oct) (${config.unit})`;
                const hoverUnit = config.unit;
                const hoverName = config.name;

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years, 
                        y: station.values, // 'values' contiene las medianas anuales
                        name: `${station.name} (${elevationText})`,
                        type: 'scatter', mode: 'lines+markers', connectgaps: false,
                        line: { color: stationColorMap[stationCode] || '#333' }, 
                        marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A침o: %{x}<br>Med. ${hoverName}: %{y:.1f} ${hoverUnit}<extra></extra>`, // Texto hover ajustado
                    };
                });

                const layout = {
                    title: 'Altura de Nieve - Mediana Anual (May-Oct) (A침os V치lidos)', // T칤tulo ajustado
                    xaxis: { title: 'A침o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest',
                    legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log("Gr치fico anual SD Median renderizado."); 

            } catch (error) { console.error("Error en renderBasinAnnualMedianPlot_SD:", error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }
        // --- FIN CORRECCI칍N ---


        // --- CORRECCI칍N: Funci칩n REESCRITA para AT (Mediana) ---
        async function renderBasinAnnualMedianPlot_AT(featureId, hierarchyKey, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            // Oculta el selector de min/max, ya no es relevante
            document.getElementById('at-stats-selector-container').style.display = 'none'; 

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando mediana anual de temperatura (May-Oct)...</p>`;
            
            // Construye la URL del archivo CORRECTO del backend
            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_at_annual_median.json?v=${Date.now()}`; 
            console.log("Intentando cargar JSON anual AT Median:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de mediana anual de temperatura.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualMedianPlot_AT: No hay datos."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos de mediana anual de temperatura disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? Infinity : stationB.elevation;
                    return elevA - elevB; // Ascendente para Temperatura
                });
                
                const config = VARIABLE_UI_CONFIG['at']; 
                const yAxisTitle = `Mediana Anual (May-Oct) (${config.unit})`;
                const hoverUnit = config.unit;
                const hoverName = config.name;

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years, 
                        y: station.values, // 'values' contiene las medianas
                        name: `${station.name} (${elevationText})`,
                        type: 'scatter', mode: 'lines+markers', connectgaps: false,
                        line: { color: stationColorMap[stationCode] || '#333' }, 
                        marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A침o: %{x}<br>Med. ${hoverName}: %{y:.1f} ${hoverUnit}<extra></extra>`,
                    };
                });

                const layout = {
                    title: 'Temperatura - Mediana Anual (May-Oct) (A침os V치lidos)', // T칤tulo ajustado
                    xaxis: { title: 'A침o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest',
                    legend: { 
                        traceorder: 'normal', 
                        title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, 
                        bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' 
                    },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log(`Gr치fico anual AT Median renderizado.`); 

            } catch (error) { 
                console.error("Error en renderBasinAnnualMedianPlot_AT:", error); 
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
            }
        }
        // --- FIN CORRECCI칍N ---

    </script>
</body>
</html>