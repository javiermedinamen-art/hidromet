<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HidroMet</title>
    
    <link rel="icon" type="image/png" href="images/favicon3.png">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Roboto', sans-serif; color: #333; background-color: #f0f2f5; margin: 0; padding: 0; }
        .main-container { width: 95%; max-width: 1400px; margin: 30px auto; background: #ffffff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 20px; }
        h1 { color: #004d99; display: flex; font-weight: 300; letter-spacing: 1px; margin: 20px auto; font-size: 32px; justify-content: center; align-items: center; text-align: center; }
        .title-logo { height: 64px; margin-right: 2px; }
        .dashboard-layout { display: flex; flex-wrap: wrap; gap: 20px; min-height: 650px; }
        .map-panel { flex: 1.2; min-width: 500px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); border: 1px solid #e0e0e0; }
        .data-panel { flex: 1; min-width: 400px; background-color: #ffffff; border-radius: 8px; padding: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; border: 1px solid #e0e0e0; }
        #mapa { height: 100%; min-height: 500px; width: 100%; border: none; }
        #chartContainer { flex-grow: 1; width: 100%; display: block; padding: 0; box-sizing: border-box; position: relative; }
        .controls { margin-bottom: 10px; padding: 8px; background-color: #e9ecef; border-radius: 6px; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; width: 100%; box-sizing: border-box; }
        .info { padding: 6px 8px; font: 14px/16px 'Roboto', sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend i { width: 10px; height: 10px; float: left; margin-right: 8px; border-radius: 50%; border: 1px solid #000; }
        .hierarchy-selector-container { background-color: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 20px; text-align: center; border: 1px solid #dee2e6; }
        .hierarchy-selector-container label { margin-right: 10px; font-weight: 500; color: #495057; }
        #hierarchy-select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; min-width: 200px; }
        .basin-comparator-section { margin-top: 30px; padding: 20px; background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); }
        .basin-comparator-section h2 { color: #004d99; font-weight: 300; text-align: center; margin-top: 0; margin-bottom: 20px; }
        #basinChartContainer { width: 100%; min-height: 550px; } 

        #yearButtonsContainer, #basinYearButtonsContainer {
            display: flex;
            justify-content: center;
            overflow-x: auto;      
            white-space: nowrap;  
            gap: 6px;
            margin-bottom: 10px;
            padding: 6px;
            scrollbar-width: thin;
        }
        #yearButtonsContainer button, #basinYearButtonsContainer button {
            flex: 0 0 auto;
            background-color: #e9ecef;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        #yearButtonsContainer button:hover, #basinYearButtonsContainer button:hover,
        #yearButtonsContainer button.active, #basinYearButtonsContainer button.active {
            background-color: #007bff;
            color: white;
        }
        ::-webkit-scrollbar { height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #007bff; border-radius: 4px; }

        /* --- 隆NUEVO ESTILO PARA LA CAJA METODOLGICA! --- */
        .methodology-box {
            margin-top: 25px;
            padding: 15px 20px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            color: #495057;
        }
        .methodology-box h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #004d99;
            font-weight: 500;
        }
        .methodology-box p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        .methodology-box ul {
            margin-top: 5px;
            margin-bottom: 10px;
            padding-left: 20px;
        }
        .methodology-box li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>
            <img src="images/favicon3.png" alt="Logo HidroMet" class="title-logo">
            <b>HidroMet: </b> &nbsp; Explorador de Datos Hidrometeorol贸gicos Depurados de Chile
        </h1>
        
        <div class="hierarchy-selector-container">
            <label for="hierarchy-select">Seleccionar Nivel de An谩lisis:</label>
            <select id="hierarchy-select">
                <option value="cuencas" selected>Cuencas</option>
                <option value="subcuencas">Subcuencas</option>
                <option value="subsubcuencas">Subsubcuencas</option>
            </select>
        </div>
        
        <div class="dashboard-layout">
            <div class="map-panel"><div id="mapa"></div></div>
            <div class="data-panel">
                <div class="controls">
                    <select id="station-select" onchange="displayTimeSeries(this.value)">
                        <option value="" selected disabled>--- Seleccione una Estaci贸n ---</option>
                    </select>
                </div>
                <div id="yearButtonsContainer"></div>
                <div id="chartContainer" class="plotly-graph-div">
                    <p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;">Seleccione una estaci贸n en el mapa o en el selector...</p>
                </div>
            </div>
        </div>

        <div class="basin-comparator-section">
            <h2 id="comparator-title">An谩lisis Comparativo por Cuenca/Subcuenca</h2>
            <div id="basinYearButtonsContainer"></div>
            <div id="basinChartContainer" class="plotly-graph-div">
                <p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;">
                    Seleccione un nivel de an谩lisis y haga clic en un pol铆gono del mapa para comparar.
                </p>
            </div>

            <div class="methodology-box">
                <h4>Nota Metodol贸gica </h4>
                <p>
                    <strong>Acumulado Mensual:</strong> Un mes se muestra en el gr谩fico solo si contiene m谩s del <strong>80%</strong> de los d铆as con datos de precipitaci贸n.
                </p>
                <p>
                    <strong>Acumulado Anual:</strong> Un a帽o se considera v谩lido y se muestra en el gr谩fico si cumple <strong>ambas</strong> condiciones:
                    <ul>
                        <li>Tiene al menos <strong>9 meses</strong> que cumplen el criterio del 80% de datos diarios.</li>
                        <li>Contiene datos para todos sus <strong>"meses hidrol贸gicamente significativos"</strong> (aquellos que hist贸ricamente aportan el 75% del total anual de precipitaci贸n para esa estaci贸n).</li>
                    </ul>
                </p>
                <p>Este doble criterio asegura que los totales anuales sean representativos y no subestimen la precipitaci贸n por la ausencia de datos durante los meses m谩s importantes.</p>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // --- CONFIGURACIN Y VARIABLES GLOBALES ---
        Plotly.setPlotConfig({locale: 'es'});
        const DATA_STATIC_BASE_URL = 'data_static'; 
        const ZOOM_THRESHOLD = 10;
        let mapa = null;
        let layerControl = null;
        let estacionesLayer = null; 
        let stationNameMap = {}; 
        let cuencasLayer = null;
        let subcuencasLayer = null;
        let subsubcuencasLayer = null;
        let highlightedFeature = null;
        let currentBasinFullData = null;
        let stationColorMap = {};

        const HIGH_CONTRAST_PALETTE = ['#332288', '#117733', '#44AA99', '#88CCEE', '#DDCC77', '#CC6677', '#AA4499', '#882255', '#E69F00', '#56B4E9', '#009E73', '#F0E442'];
        
        const HIERARCHY_CONFIG = {
            'cuencas': { url: `${DATA_STATIC_BASE_URL}/cuencas.geojson`, id_property: 'COD_CUEN', name_property: 'NOM_CUEN', name: 'Cuenca' },
            'subcuencas': { url: `${DATA_STATIC_BASE_URL}/subcuencas.geojson`, id_property: 'COD_SUBC', name_property: 'NOM_SUBC', name: 'Subcuenca' },
            'subsubcuencas': { url: `${DATA_STATIC_BASE_URL}/subsubcuencas.geojson`, id_property: 'COD_SSUBC', name_property: 'NOM_SSUBC', name: 'Subsubcuenca' }
        };
        const FUENTES_MAP = { 'DGA': '#007bff', 'CEAZAMET': '#28a745', 'CIEP': '#ffc107', 'CECS': '#dc3545', 'DMC': '#6f42c1', 'CR2': '#fd7e14', 'Otro': '#6c757d' };
        
        window.onload = () => {
            inicializarMapa();
            cargarDatosGeoespaciales();
            switchHierarchyLayer('cuencas');
            document.getElementById('hierarchy-select').addEventListener('change', (e) => switchHierarchyLayer(e.target.value));
        };

        function inicializarMapa() {
            mapa = L.map('mapa').setView([-33.4489, -70.6693], 5);
            mapa.createPane('cuencasPane');
            mapa.getPane('cuencasPane').style.zIndex = 350;

            const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                attribution: '漏 OpenStreetMap contributors' 
            }).addTo(mapa);
            
            const satelite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                attribution: '漏 Esri' 
            });

            const topografico = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: '漏 Esri'
            });

            const baseMaps = {
                "Calles": osm, 
                "Satelital": satelite,
                "Topogr谩fico": topografico 
            };
            
            layerControl = L.control.layers(baseMaps, {}).addTo(mapa);

            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function () {
                const div = L.DomUtil.create('div', 'info legend');
                let legendHtml = '<b>Fuentes</b>';
                const items = Object.keys(FUENTES_MAP).map(key => `<i style="background:${FUENTES_MAP[key]}"></i> ${key}`);
                legendHtml += `<div style="margin-top: 4px;">${items.join('<br>')}</div>`;
                div.innerHTML = legendHtml;
                return div;
            };
            legend.addTo(mapa);
            
            mapa.on('zoomend', updateLayerInteractivity);
        }

        function getColorByFuente(fuente) {
            fuente = (fuente || '').toUpperCase().replace(/_NERC/g, ''); 
            return FUENTES_MAP[fuente] || '#6c757d';
        }

        async function cargarDatosGeoespaciales() {
            try {
                const [nameResponse, geoResponse] = await Promise.all([
                    fetch(`${DATA_STATIC_BASE_URL}/station_names.json`),
                    fetch(`${DATA_STATIC_BASE_URL}/estaciones.geojson`)
                ]);
                stationNameMap = await nameResponse.json();
                if (!geoResponse.ok) throw new Error(`Error al cargar GeoJSON de estaciones: ${geoResponse.status}`);
                const geojsonData = await geoResponse.json();
                
                if (estacionesLayer) { mapa.removeLayer(estacionesLayer); layerControl.removeLayer(estacionesLayer); }
                const stationSelect = document.getElementById('station-select');
                stationSelect.innerHTML = '<option value="" selected disabled>--- Seleccione una Estaci贸n ---</option>';

                estacionesLayer = L.geoJSON(geojsonData, {
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, {radius: 6, fillColor: getColorByFuente(feature.properties.fuente), color: "#000", weight: 1, fillOpacity: 0.8}),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        if (props && props.code_internal) {
                            stationSelect.appendChild(new Option(`${props.name || 'N/A'} (${props.code_internal})`, props.code_internal));
                            const html = `
                                <div style="line-height: 1.5;">
                                    <h4 style="margin: 0 0 5px 0; color:${getColorByFuente(props.fuente)};">${props.name || 'N/A'}</h4>
                                    <b>C贸digo:</b> ${props.code_internal}<br>
                                    <b>Elevaci贸n:</b> ${props.elevation || 'N/A'} m.s.n.m.<br>
                                    <b>Cuenca:</b> ${props.basin || 'N/A'}<br>
                                    <b>Fuente:</b> ${props.fuente || 'N/A'}
                                </div>`;
                            layer.bindPopup(html);
                        }
                    }
                }).addTo(mapa);
                
                layerControl.addOverlay(estacionesLayer, "Estaciones");
                const bounds = estacionesLayer.getBounds();
                if (bounds.isValid()) mapa.fitBounds(bounds.pad(0.1));

                updateLayerInteractivity();
            } catch (error) { console.error("Error al cargar datos de estaciones:", error); }
        }

        async function displayTimeSeries(stationCode) {
            if (!stationCode) return;
            const chartDiv = document.getElementById('chartContainer');
            Plotly.purge(chartDiv);
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando serie temporal...</p>`;
            document.getElementById('station-select').value = stationCode;
            try {
                const response = await fetch(`${DATA_STATIC_BASE_URL}/${stationCode}.csv`);
                if (!response.ok) throw new Error(`CSV no encontrado`);
                const csvText = await response.text();
                const data = Papa.parse(csvText, {header: true, dynamicTyping: true, skipEmptyLines: true}).data;
                const stationName = stationNameMap[stationCode] || stationCode;

                const years = [...new Set(data.map(d => parseInt(d.Fecha.substring(0, 4), 10)))].sort();
                const container = document.getElementById("yearButtonsContainer");
                container.innerHTML = "";

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderPlot(data, stationName, null, allBtn);
                container.appendChild(allBtn);

                years.forEach(y => {
                    const btn = document.createElement("button");
                    btn.textContent = y;
                    btn.onclick = () => renderPlot(data.filter(d => parseInt(d.Fecha.substring(0, 4), 10) === y), stationName, y, btn);
                    container.appendChild(btn);
                });
                renderPlot(data, stationName, null, allBtn);
            } catch (error) { console.error(error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }
                
        function renderPlot(data, stationName, year, activeBtn) {
            document.querySelectorAll("#yearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");
            const trace = { 
                x: data.map(d => d.Fecha), 
                y: data.map(d => {
                    let v = d.Precipitacion_mm;
                    if(typeof v === 'string') v = parseFloat(v.trim());
                    return isFinite(v) ? v : null;
                }), 
                type: 'bar', 
                marker: { color: "#007bff" } 
            };
            const layout = {
                title: `Precipitaci贸n diaria - ${stationName}${year ? ` (${year})` : ""}`,
                margin: { l: 50, r: 50, t: 60, b: 50 }, 
                xaxis: { title: "Fecha", rangeslider: {visible: false} },
                yaxis: { title: "Precipitaci贸n (mm)" },
                hovermode: "x unified",
            };
            Plotly.react("chartContainer", [trace], layout, {responsive: true});
        }

        async function switchHierarchyLayer(hierarchyKey) {
            if (cuencasLayer) mapa.removeLayer(cuencasLayer);
            if (subcuencasLayer) mapa.removeLayer(subcuencasLayer);
            if (subsubcuencasLayer) mapa.removeLayer(subsubcuencasLayer);
            if (layerControl) {
                if(cuencasLayer) layerControl.removeLayer(cuencasLayer);
                if(subcuencasLayer) layerControl.removeLayer(subcuencasLayer);
                if(subsubcuencasLayer) layerControl.removeLayer(subsubcuencasLayer);
            }
            highlightedFeature = null;

            const config = HIERARCHY_CONFIG[hierarchyKey];
            if (!config) return;

            try {
                const response = await fetch(config.url);
                if (!response.ok) throw new Error(`No se pudo cargar ${config.url}`);
                const geojsonData = await response.json();
                const style = { color: "#1a5276", weight: 1.5, opacity: 0.6, fillOpacity: 0.2 };
                const highlightStyle = { weight: 3, color: '#e74c3c', fillOpacity: 0.4 };

                const newLayer = L.geoJSON(geojsonData, {
                    style: style,
                    pane: 'cuencasPane',
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const nEstaciones = props.n_estaciones || 0;
                        
                        const popupContent = `
                            <div style="line-height: 1.5;">
                                <h4 style="margin: 0 0 5px 0; color:#1a5276;">${config.name}: ${props[config.name_property] || 'N/A'}</h4>
                                <b>C贸digo:</b> ${props[config.id_property]}<br>
                                <b>N掳 de estaciones:</b> ${nEstaciones}
                            </div>`;
                        
                        layer.bindPopup(popupContent);

                        layer.on({
                            click: e => {
                                if (highlightedFeature) {
                                    newLayer.resetStyle(highlightedFeature);
                                }
                                highlightedFeature = e.target;
                                e.target.setStyle(highlightStyle);
                                displayBasinChart(props[config.id_property], props[config.name_property] || '', hierarchyKey);
                                const comparatorSection = document.querySelector('.basin-comparator-section');
                                comparatorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        });
                    }
                }).addTo(mapa);
                
                let layerName = "Capa";
                if (hierarchyKey === 'cuencas') { 
                    cuencasLayer = newLayer;
                    layerName = "Cuencas";
                } else if (hierarchyKey === 'subcuencas') {
                    subcuencasLayer = newLayer;
                    layerName = "Subcuencas";
                } else {
                    subsubcuencasLayer = newLayer;
                    layerName = "Subsubcuencas";
                }
                
                layerControl.addOverlay(newLayer, layerName);
                updateLayerInteractivity();

            } catch (error) { console.error(`Error al cargar ${hierarchyKey}:`, error); }
        }

        function updateLayerInteractivity() {
            if (!mapa) return;
            const zoom = mapa.getZoom();

            let activeHierarchyLayer;
            const selectedHierarchy = document.getElementById('hierarchy-select').value;
            if (selectedHierarchy === 'cuencas') {
                activeHierarchyLayer = cuencasLayer;
            } else if (selectedHierarchy === 'subcuencas') {
                activeHierarchyLayer = subcuencasLayer;
            } else {
                activeHierarchyLayer = subsubcuencasLayer;
            }

            if (activeHierarchyLayer) {
                activeHierarchyLayer.eachLayer(layer => {
                    if (zoom < ZOOM_THRESHOLD) {
                        if (!layer.listens('mouseover')) {
                            layer.on({
                                mouseover: function (e) { this.openPopup(e.latlng); },
                                mouseout: function () { this.closePopup(); },
                                mousemove: function (e) {
                                    if (this.isPopupOpen()) {
                                        this.getPopup().setLatLng(e.latlng);
                                    }
                                }
                            });
                        }
                    } else {
                        layer.off('mouseover mouseout mousemove');
                        layer.closePopup();
                    }
                });
            }

            if (estacionesLayer) {
                estacionesLayer.eachLayer(layer => {
                    const props = layer.feature.properties;
                    if (zoom < ZOOM_THRESHOLD) {
                        layer.setRadius(3);
                        layer.off('mouseover mouseout click');
                    } else {
                        layer.setRadius(6);
                        if (!layer.listens('mouseover')) {
                            layer.on({
                                mouseover: function () { this.openPopup(); },
                                mouseout: function () { this.closePopup(); },
                                click: () => { displayTimeSeries(props.code_internal); }
                            });
                        }
                    }
                });
            }
        }

        async function displayBasinChart(featureId, featureName, hierarchyKey) {
            const chartDiv = document.getElementById('basinChartContainer');
            const buttonContainer = document.getElementById('basinYearButtonsContainer');
            Plotly.purge(chartDiv);
            buttonContainer.innerHTML = '';

            const config = HIERARCHY_CONFIG[hierarchyKey];
            const locationTitle = `${config.name} ${featureName} (${featureId})`;
            document.getElementById('comparator-title').innerText = `An谩lisis Comparativo para ${locationTitle}`;
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de ${locationTitle}...</p>`;

            try {
                const response = await fetch(`${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}.json`);
                if (!response.ok) throw new Error(`No se encontraron datos para ${locationTitle}`);
                
                currentBasinFullData = await response.json();
                
                stationColorMap = {};
                Object.keys(currentBasinFullData).forEach((stationCode, i) => {
                    stationColorMap[stationCode] = HIGH_CONTRAST_PALETTE[i % HIGH_CONTRAST_PALETTE.length];
                });
                
                const allDates = Object.values(currentBasinFullData).flatMap(s => s.dates);
                const years = [...new Set(allDates.map(d => parseInt(d.substring(0, 4), 10)))].sort();

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderBasinPlot(currentBasinFullData, null, allBtn);
                buttonContainer.appendChild(allBtn);

                years.forEach(year => {
                    const btn = document.createElement("button");
                    btn.textContent = year;
                    btn.onclick = () => {
                        const filteredData = {};
                        for (const stationCode in currentBasinFullData) {
                            const station = currentBasinFullData[stationCode];
                            const filteredDates = [], filteredValues = [];
                            let hasNonNullData = false;
                            
                            station.dates.forEach((date, i) => {
                                if (parseInt(date.substring(0, 4), 10) === year) {
                                    filteredDates.push(date);
                                    filteredValues.push(station.values[i]);
                                    if (station.values[i] !== null) hasNonNullData = true;
                                }
                            });
                            
                            if (hasNonNullData) {
                                filteredData[stationCode] = { ...station, dates: filteredDates, values: filteredValues };
                            }
                        }
                        renderBasinPlot(filteredData, year, btn);
                    };
                    buttonContainer.appendChild(btn);
                });

                const annualBtn = document.createElement("button");
                annualBtn.textContent = "Acumulaci贸n Anual";
                annualBtn.onclick = () => renderBasinAnnualPlot(featureId, hierarchyKey, annualBtn);
                buttonContainer.appendChild(annualBtn);
                
                renderBasinPlot(currentBasinFullData, null, allBtn);
            } catch (error) {
                console.error(error);
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
                currentBasinFullData = null;
            }
        }

        function renderBasinPlot(dataToPlot, year, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const sortedStations = Object.entries(dataToPlot).sort(([, stationA], [, stationB]) => {
                const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                return elevB - elevA;
            });

            const traces = sortedStations.map(([stationCode, station]) => {
                const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                return { 
                    x: station.dates, 
                    y: station.values, 
                    mode: 'lines+markers', 
                    name: `${station.name} (${elevationText})`, 
                    type: 'scatter',
                    line: { color: stationColorMap[stationCode] },
                    marker: { color: stationColorMap[stationCode] },
                    hovertemplate: `<b>${station.name}</b><br>%{x|%B de %Y}<br>Precipitaci贸n: %{y:.1f} mm<extra></extra>`,
                };
            });

            const xAxisConfig = { title: 'Fecha' };
            if (year) {
                xAxisConfig.range = [`${year}-01-01`, `${year}-12-31`];
                xAxisConfig.tickformat = '%B';
            }

            const layout = {
                title: `Precipitaci贸n Acumulada Mensual${year ? ` (${year})` : ''}`,
                xaxis: xAxisConfig,
                yaxis: { title: 'Precipitaci贸n (mm)' },
                hovermode: 'closest',
                showlegend: true,
                legend: { 
                    traceorder: 'normal',
                    title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } },
                    bgcolor: 'rgba(248, 249, 250, 0.95)',
                    bordercolor: '#dee2e6', 
                    borderwidth: 1,
                    borderRadius: 8,
                    x: 1.02, 
                    xanchor: 'left' 
                },
                margin: { r: 250 }
            };
            
            Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
        }
        
        async function renderBasinAnnualPlot(featureId, hierarchyKey, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de acumulaci贸n anual...</p>`;

            try {
                const response = await fetch(`${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_annual.json`);
                if (!response.ok) throw new Error(`No se encontraron datos de acumulaci贸n anual.`);
                const annualData = await response.json();

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years,
                        y: station.values,
                        name: `${station.name} (${elevationText})`,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: { color: stationColorMap[stationCode] || '#333' },
                        marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A帽o: %{x}<br>Precipitaci贸n: %{y:.1f} mm<extra></extra>`,
                    };
                });

                const layout = {
                    // --- TTULO ACTUALIZADO ---
                    title: 'Precipitaci贸n Acumulada Anual (A帽os Hidrol贸gicamente V谩lidos)',
                    xaxis: { title: 'A帽o', type: 'category' },
                    yaxis: { title: 'Precipitaci贸n Acumulada (mm)' },
                    hovermode: 'closest',
                    legend: {
                        traceorder: 'normal',
                        title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } },
                        bgcolor: 'rgba(248, 249, 250, 0.95)',
                        bordercolor: '#dee2e6',
                        borderwidth: 1,
                        borderRadius: 8,
                        x: 1.02,
                        xanchor: 'left'
                    },
                    margin: { r: 250 }
                };

                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});

            } catch (error) {
                console.error(error);
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
            }
        }
    </script>
</body>
</html>