<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HidroMet</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Roboto', sans-serif; color: #333; background-color: #f0f2f5; margin: 0; padding: 0; }
        .main-container { width: 95%; max-width: 1400px; margin: 30px auto; background: #ffffff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 20px; }
        h1 { color: #004d99; font-weight: 300; letter-spacing: 1px; margin: 20px auto; font-size: 26px; text-align: center; }
        .dashboard-layout { display: flex; flex-wrap: wrap; gap: 20px; min-height: 650px; }
        .map-panel { flex: 1; min-width: 45%; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); border: 1px solid #e0e0e0; }
        .data-panel { flex: 1; min-width: 45%; background-color: #ffffff; border-radius: 8px; padding: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; border: 1px solid #e0e0e0; }
        #mapa { height: 100%; min-height: 650px; width: 100%; border: none; }
        #chartContainer { flex-grow: 1; width: 100%; display: block; padding: 0; box-sizing: border-box; position: relative; }
        .controls { margin-bottom: 10px; padding: 8px; background-color: #e9ecef; border-radius: 6px; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; width: 100%; box-sizing: border-box; }
        .info { padding: 6px 8px; font: 14px/16px 'Roboto', sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend i { width: 10px; height: 10px; float: left; margin-right: 8px; border-radius: 50%; border: 1px solid #000; }
        .hierarchy-selector-container { background-color: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 20px; text-align: center; border: 1px solid #dee2e6; }
        .hierarchy-selector-container label { margin-right: 10px; font-weight: 500; color: #495057; }
        #hierarchy-select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; min-width: 200px; }
        .basin-comparator-section { margin-top: 30px; padding: 20px; background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); }
        .basin-comparator-section h2 { color: #004d99; font-weight: 300; text-align: center; margin-top: 0; margin-bottom: 20px; }
        #basinChartContainer { width: 100%; min-height: 450px; }

        #yearButtonsContainer, #basinYearButtonsContainer {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
            padding: 6px;
        }
        #yearButtonsContainer button, #basinYearButtonsContainer button {
            flex: 0 0 auto;
            background-color: #e9ecef;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        #yearButtonsContainer button:hover, #basinYearButtonsContainer button:hover,
        #yearButtonsContainer button.active, #basinYearButtonsContainer button.active {
            background-color: #007bff;
            color: white;
        }
        ::-webkit-scrollbar { height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #007bff; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1><b>HidroMet:</b> Explorador de Datos Hidrometeorológicos Depurados de Chile</h1>
        
        <div class="hierarchy-selector-container">
            <label for="hierarchy-select">Seleccionar Nivel de Análisis:</label>
            <select id="hierarchy-select">
                <option value="cuencas" selected>Cuencas</option>
                <option value="subcuencas">Subcuencas</option>
            </select>
        </div>
        
        <div class="dashboard-layout">
            <div class="map-panel"><div id="mapa"></div></div>
            <div class="data-panel">
                <div class="controls">
                    <select id="station-select" onchange="displayTimeSeries(this.value)">
                        <option value="" selected disabled>--- Seleccione una Estación ---</option>
                    </select>
                </div>
                <div id="yearButtonsContainer"></div>
                <div id="chartContainer" class="plotly-graph-div">
                    <p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;">Seleccione una estación...</p>
                </div>
            </div>
        </div>

        <div class="basin-comparator-section">
            <h2 id="comparator-title">Análisis Comparativo por Cuenca/Subcuenca</h2>
            <div id="basinYearButtonsContainer"></div>
            <div id="basinChartContainer" class="plotly-graph-div">
                <p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;">
                    Seleccione un nivel de análisis y haga clic en un polígono del mapa para comparar.
                </p>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // --- VARIABLES GLOBALES ---
        const DATA_STATIC_BASE_URL = 'data_static'; 
        let mapa = null;
        let layerControl = null;
        let estacionesLayer = null; 
        let stationNameMap = {}; 
        let cuencasLayer = null;
        let subcuencasLayer = null;
        let highlightedFeature = null;
        let currentBasinFullData = null;
        let stationColorMap = {};

        const HIGH_CONTRAST_PALETTE = [
            '#332288', '#117733', '#44AA99', '#88CCEE', '#DDCC77', 
            '#CC6677', '#AA4499', '#882255', '#E69F00', '#56B4E9', 
            '#009E73', '#F0E442'
        ];

        const HIERARCHY_CONFIG = {
            'cuencas': { url: `${DATA_STATIC_BASE_URL}/cuencas.geojson`, id_property: 'COD_CUEN', name_property: 'NOM_CUEN', name: 'Cuenca' },
            'subcuencas': { url: `${DATA_STATIC_BASE_URL}/subcuencas.geojson`, id_property: 'COD_SUBC', name_property: 'NOM_SUBC', name: 'Subcuenca' }
        };

        const FUENTES_MAP = { 'DGA': '#007bff', 'CEAZAMET': '#28a745', 'CIEP': '#ffc107', 'CECS': '#dc3545', 'DMC': '#6f42c1', 'CR2': '#fd7e14', 'Otro': '#6c757d' };
        
        window.onload = () => {
            inicializarMapa();
            cargarDatosGeoespaciales();
            switchHierarchyLayer('cuencas');
            document.getElementById('hierarchy-select').addEventListener('change', (e) => switchHierarchyLayer(e.target.value));
        };

        function inicializarMapa() {
            mapa = L.map('mapa').setView([-33.4489, -70.6693], 5);
            mapa.createPane('cuencasPane');
            mapa.getPane('cuencasPane').style.zIndex = 350;
            const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Map data © OpenStreetMap contributors' }).addTo(mapa);
            const satelite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
            layerControl = L.control.layers({"Calles": osm, "Satelital": satelite}, {}).addTo(mapa);
            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function () {
                const div = L.DomUtil.create('div', 'info legend');
                let legendHtml = '<b>Fuentes</b>';
                const items = Object.keys(FUENTES_MAP).map(key => `<i style="background:${FUENTES_MAP[key]}"></i> ${key}`);
                legendHtml += `<div style="margin-top: 4px;">${items.join('<br>')}</div>`;
                div.innerHTML = legendHtml;
                return div;
            };
            legend.addTo(mapa);
        }

        function getColorByFuente(fuente) {
            fuente = (fuente || '').toUpperCase().replace(/_NERC/g, ''); 
            return FUENTES_MAP[fuente] || '#6c757d';
        }

        async function cargarDatosGeoespaciales() {
            try {
                const [nameResponse, geoResponse] = await Promise.all([
                    fetch(`${DATA_STATIC_BASE_URL}/station_names.json`),
                    fetch(`${DATA_STATIC_BASE_URL}/estaciones.geojson`)
                ]);
                stationNameMap = await nameResponse.json();
                if (!geoResponse.ok) throw new Error(`Error al cargar GeoJSON de estaciones: ${geoResponse.status}`);
                const geojsonData = await geoResponse.json();
                
                if (estacionesLayer) { mapa.removeLayer(estacionesLayer); layerControl.removeLayer(estacionesLayer); }

                const stationSelect = document.getElementById('station-select');
                stationSelect.innerHTML = '<option value="" selected disabled>--- Seleccione una Estación ---</option>';

                estacionesLayer = L.geoJSON(geojsonData, {
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, {radius: 6, fillColor: getColorByFuente(feature.properties.fuente), color: "#000", weight: 1, fillOpacity: 0.8}),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        if (props && props.code_internal) {
                            stationSelect.appendChild(new Option(`${props.name || 'N/A'} (${props.code_internal})`, props.code_internal));
                            const html = `
                                <div style="line-height: 1.5;">
                                    <h4 style="margin: 0 0 5px 0; color:${getColorByFuente(props.fuente)};">${props.name || 'N/A'}</h4>
                                    <b>Código:</b> ${props.code_internal}<br>
                                    <b>Elevación:</b> ${props.elevation || 'N/A'} m.s.n.m.<br>
                                    <b>Cuenca:</b> ${props.basin || 'N/A'}<br>
                                    <b>Fuente:</b> ${props.fuente || 'N/A'}
                                </div>
                                <button onclick="displayTimeSeries('${props.code_internal}')" style="width: 100%; margin-top: 10px; padding: 4px; cursor: pointer;">Ver Serie</button>`;
                            layer.bindPopup(html);
                        }
                    }
                }).addTo(mapa);
                
                layerControl.addOverlay(estacionesLayer, "Estaciones");
                const bounds = estacionesLayer.getBounds();
                if (bounds.isValid()) mapa.fitBounds(bounds.pad(0.1));
            } catch (error) { console.error("Error al cargar datos de estaciones:", error); }
        }

        async function displayTimeSeries(stationCode) {
            if (!stationCode) return;
            const chartDiv = document.getElementById('chartContainer');
            Plotly.purge(chartDiv);
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando serie temporal...</p>`;
            document.getElementById('station-select').value = stationCode;
            try {
                const response = await fetch(`${DATA_STATIC_BASE_URL}/${stationCode}.csv`);
                if (!response.ok) throw new Error(`CSV no encontrado`);
                const csvText = await response.text();
                const data = Papa.parse(csvText, {header: true, dynamicTyping: true, skipEmptyLines: true}).data;
                const stationName = stationNameMap[stationCode] || stationCode;

                const years = [...new Set(data.map(d => new Date(d.Fecha).getFullYear()))].sort();
                const container = document.getElementById("yearButtonsContainer");
                container.innerHTML = "";

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderPlot(data, stationName, null, allBtn);
                container.appendChild(allBtn);

                years.forEach(y => {
                    const btn = document.createElement("button");
                    btn.textContent = y;
                    btn.onclick = () => renderPlot(data.filter(d => new Date(d.Fecha).getFullYear() === y), stationName, y, btn);
                    container.appendChild(btn);
                });
                renderPlot(data, stationName, null, allBtn);
            } catch (error) { console.error(error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }
            
        function renderPlot(data, stationName, year, activeBtn) {
            document.querySelectorAll("#yearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");
            const trace = { 
                x: data.map(d => d.Fecha), 
                y: data.map(d => {
                    let v = d.Precipitacion_mm;
                    if(typeof v === 'string') v = parseFloat(v.trim());
                    return isFinite(v) ? v : null;
                }), 
                type: 'bar', 
                marker: { color: "#007bff" } 
            };
            const layout = {
                title: `Precipitación diaria - ${stationName}${year ? ` (${year})` : ""}`,
                margin: { l: 50, r: 50, t: 60, b: 50 }, 
                xaxis: { title: "Fecha", rangeslider: {visible: true} },
                yaxis: { title: "Precipitación (mm)" },
                hovermode: "x unified",
            };
            Plotly.react("chartContainer", [trace], layout, {responsive: true});
        }

        async function switchHierarchyLayer(hierarchyKey) {
            if (cuencasLayer) mapa.removeLayer(cuencasLayer);
            if (subcuencasLayer) mapa.removeLayer(subcuencasLayer);
            if (layerControl) {
                if(cuencasLayer) layerControl.removeLayer(cuencasLayer);
                if(subcuencasLayer) layerControl.removeLayer(subcuencasLayer);
            }
            highlightedFeature = null;

            const config = HIERARCHY_CONFIG[hierarchyKey];
            if (!config) return;

            try {
                const response = await fetch(config.url);
                if (!response.ok) throw new Error(`No se pudo cargar ${config.url}`);
                const geojsonData = await response.json();
                const style = { color: "#1a5276", weight: 1.5, opacity: 0.6, fillOpacity: 0.2 };
                const highlightStyle = { weight: 3, color: '#e74c3c', fillOpacity: 0.4 };

                const newLayer = L.geoJSON(geojsonData, {
                    style: style,
                    pane: 'cuencasPane',
                    onEachFeature: (feature, layer) => {
                        layer.on({
                            mouseover: e => { if (e.target !== highlightedFeature) e.target.setStyle(highlightStyle); },
                            mouseout: e => { if (e.target !== highlightedFeature) newLayer.resetStyle(e.target); },
                            click: e => {
                                if (highlightedFeature) newLayer.resetStyle(highlightedFeature);
                                highlightedFeature = e.target;
                                e.target.setStyle(highlightStyle);
                                const featureId = feature.properties[config.id_property];
                                const featureName = feature.properties[config.name_property] || '';
                                displayBasinChart(featureId, featureName, hierarchyKey);
                            }
                        });
                    }
                }).addTo(mapa);
                
                if (hierarchyKey === 'cuencas') { cuencasLayer = newLayer; layerControl.addOverlay(cuencasLayer, "Cuencas"); } 
                else { subcuencasLayer = newLayer; layerControl.addOverlay(subcuencasLayer, "Subcuencas"); }
            } catch (error) { console.error(`Error al cargar ${hierarchyKey}:`, error); }
        }

        async function displayBasinChart(featureId, featureName, hierarchyKey) {
            const chartDiv = document.getElementById('basinChartContainer');
            const buttonContainer = document.getElementById('basinYearButtonsContainer');
            Plotly.purge(chartDiv);
            buttonContainer.innerHTML = '';

            const config = HIERARCHY_CONFIG[hierarchyKey];
            const locationTitle = `${config.name} ${featureName} (${featureId})`;
            document.getElementById('comparator-title').innerText = `Análisis Comparativo para: ${locationTitle}`;
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de ${locationTitle}...</p>`;

            try {
                const response = await fetch(`${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}.json`);
                if (!response.ok) throw new Error(`No se encontraron datos para ${locationTitle}`);
                
                currentBasinFullData = await response.json();
                
                stationColorMap = {};
                Object.keys(currentBasinFullData).forEach((stationCode, i) => {
                    stationColorMap[stationCode] = HIGH_CONTRAST_PALETTE[i % HIGH_CONTRAST_PALETTE.length];
                });
                
                const years = [...new Set(Object.values(currentBasinFullData).flatMap(s => s.dates.map(d => new Date(d).getFullYear())))].sort();

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderBasinPlot(currentBasinFullData, null, allBtn);
                buttonContainer.appendChild(allBtn);

                years.forEach(year => {
                    const btn = document.createElement("button");
                    btn.textContent = year;
                    btn.onclick = () => {
                        const filteredData = {};
                        for (const stationCode in currentBasinFullData) {
                            const station = currentBasinFullData[stationCode];
                            const filteredDates = [], filteredValues = [];
                            let hasNonNullData = false;
                            
                            station.dates.forEach((date, i) => {
                                if (new Date(date).getFullYear() === year) {
                                    filteredDates.push(date);
                                    filteredValues.push(station.values[i]);
                                    if (station.values[i] !== null) hasNonNullData = true;
                                }
                            });
                            
                            if (hasNonNullData) {
                                filteredData[stationCode] = { ...station, dates: filteredDates, values: filteredValues };
                            }
                        }
                        renderBasinPlot(filteredData, year, btn);
                    };
                    buttonContainer.appendChild(btn);
                });
                renderBasinPlot(currentBasinFullData, null, allBtn);
            } catch (error) {
                console.error(error);
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
                currentBasinFullData = null;
            }
        }

        function renderBasinPlot(dataToPlot, year, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");
            const traces = Object.keys(dataToPlot).map(stationCode => {
                const station = dataToPlot[stationCode];
                const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                return { 
                    x: station.dates, 
                    y: station.values, 
                    mode: 'lines+markers', 
                    name: `${station.name} (${elevationText})`, 
                    type: 'scatter',
                    line: { color: stationColorMap[stationCode] },
                    marker: { color: stationColorMap[stationCode] },
                    hovertemplate: `<b>${station.name}</b><br>%{x|%B de %Y}<br>Precipitación: %{y:.1f} mm<extra></extra>`,
                };
            });
            const layout = {
                title: `Precipitación Mensual Acumulada${year ? ` (${year})` : ''}`,
                xaxis: { title: 'Fecha' },
                yaxis: { title: 'Precipitación (mm)' },
                hovermode: 'closest',
                showlegend: true,
                legend: { 
                    title: { text: '<b>Estaciones</b>', font: { size: 13 } }, 
                    bgcolor: 'rgba(255,255,255,0.8)', 
                    bordercolor: '#E2E2E2', 
                    borderwidth: 1, 
                    x: 1.02, 
                    xanchor: 'left' 
                },
                margin: { r: 250 }
            };
            Plotly.react('basinChartContainer', traces, layout, {responsive: true});
        }
    </script>
</body>
</html>