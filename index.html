<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HidroMet</title>
    
    <link rel="icon" type="image/png" href="images/favicon3.png">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script> 
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Roboto', sans-serif; color: #333; background-color: #f0f2f5; margin: 0; padding: 0; }
        .main-container { width: 95%; max-width: 1400px; margin: 30px auto; background: #ffffff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); padding: 20px; }
        h1 { color: #004d99; display: flex; font-weight: 300; letter-spacing: 1px; margin: 20px auto; font-size: 32px; justify-content: center; align-items: center; text-align: center; }
        .title-logo { height: 64px; margin-right: 2px; }
        .dashboard-layout { display: flex; flex-wrap: wrap; gap: 20px; min-height: 650px; }
        .map-panel { flex: 1.2; min-width: 500px; border-radius: 8px; overflow: hidden; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); border: 1px solid #e0e0e0; }
        .data-panel { flex: 1; min-width: 400px; background-color: #ffffff; border-radius: 8px; padding: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); display: flex; flex-direction: column; border: 1px solid #e0e0e0; }
        #mapa { height: 100%; min-height: 500px; width: 100%; border: none; }
        #chartContainer { flex-grow: 1; width: 100%; display: block; padding: 0; box-sizing: border-box; position: relative; }
        .controls { margin-bottom: 10px; padding: 8px; background-color: #e9ecef; border-radius: 6px; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ced4da; width: 100%; box-sizing: border-box; }
        .info { padding: 6px 8px; font: 14px/16px 'Roboto', sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend i { width: 10px; height: 10px; float: left; margin-right: 8px; border-radius: 50%; border: 1px solid #000; }
        
        .hierarchy-selector-container { 
            background-color: #f8f9fa; 
            padding: 12px 20px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            border: 1px solid #dee2e6; 
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            gap: 20px;
        }
        .selector-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .selector-group label { 
            font-weight: 500; 
            color: #495057; 
            margin: 0;
        }
        #hierarchy-select, #variable-select { 
            padding: 8px; 
            border-radius: 4px; 
            border: 1px solid #ced4da; 
            min-width: 200px;
            width: auto;
        }

        .basin-comparator-section { margin-top: 30px; padding: 20px; background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); }
        .basin-comparator-section h2 { color: #004d99; font-weight: 300; text-align: center; margin-top: 0; margin-bottom: 20px; }
        #basinChartContainer { width: 100%; min-height: 550px; } 

        #yearButtonsContainer, #basinYearButtonsContainer {
            display: flex;
            justify-content: center;
            overflow-x: auto;      
            white-space: nowrap;   
            gap: 6px;
            margin-bottom: 10px;
            padding: 6px;
            scrollbar-width: thin;
        }
        #yearButtonsContainer button, #basinYearButtonsContainer button {
            flex: 0 0 auto;
            background-color: #e9ecef;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        #yearButtonsContainer button:hover, #basinYearButtonsContainer button:hover,
        #yearButtonsContainer button.active, #basinYearButtonsContainer button.active {
            background-color: #007bff;
            color: white;
        }
        ::-webkit-scrollbar { height: 6px; }
        ::-webkit-scrollbar-thumb { background-color: #007bff; border-radius: 4px; }

        .methodology-box {
            margin-top: 25px;
            padding: 15px 20px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            color: #495057;
        }
        .methodology-box h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #004d99;
            font-weight: 500;
        }
        .methodology-box p { margin-bottom: 10px; line-height: 1.6; }
        .methodology-box ul { margin-top: 5px; margin-bottom: 10px; padding-left: 20px; }
        .methodology-box li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>
            <img src="images/favicon3.png" alt="Logo HidroMet" class="title-logo">
            <b>HidroMet: </b> &nbsp; Explorador de Datos Hidrometeorol√≥gicos Depurados de Chile
        </h1>
        
        <div class="hierarchy-selector-container">
            <div class="selector-group">
                <label for="hierarchy-select">Nivel de An√°lisis:</label>
                <select id="hierarchy-select">
                    <option value="cuencas" selected>Cuencas</option>
                    <option value="subcuencas">Subcuencas</option>
                    <option value="subsubcuencas">Subsubcuencas</option>
                </select>
            </div>
            
            <div class="selector-group">
                <label for="variable-select">Variable:</label>
                <select id="variable-select">
                    <option value="ppt" selected>Precipitaci√≥n</option>
                    <option value="sd">Altura de Nieve</option>
                    <option value="at">Temperatura</option> </select>
            </div>
        </div>
        
        <div class="dashboard-layout">
            <div class="map-panel"><div id="mapa"></div></div>
            <div class="data-panel">
                <div class="controls">
                    <select id="station-select" onchange="displayTimeSeries(this.value)">
                        <option value="" selected disabled>--- Seleccione una Estaci√≥n ---</option>
                    </select>
                </div>
                <div id="yearButtonsContainer"></div>
                <div id="chartContainer" class="plotly-graph-div">
                    <p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;">Seleccione una estaci√≥n en el mapa o en el selector...</p>
                </div>
            </div>
        </div>

        <div class="basin-comparator-section">
            <h2 id="comparator-title">An√°lisis Comparativo por Cuenca/Subcuenca</h2>
            <div id="basinYearButtonsContainer"></div>
            <div id="basinChartContainer" class="plotly-graph-div">
                <p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;">
                    Seleccione un nivel de an√°lisis y haga clic en un pol√≠gono del mapa para comparar.
                </p>
            </div>

            <div class="methodology-box" id="methodology-ppt">
                <h4>Nota Metodol√≥gica (Precipitaci√≥n) üìù</h4>
                 <p>
                    <strong>Acumulado Mensual:</strong> Un mes se muestra si contiene > <strong>80%</strong> de d√≠as con datos.
                </p>
                <p>
                    <strong>Acumulado Anual:</strong> Un a√±o es v√°lido si tiene ‚â• <strong>9 meses</strong> v√°lidos Y datos para todos sus <strong>meses hidrol√≥gicamente significativos</strong> (75% del total anual).
                </p>
            </div>
            
            <div class="methodology-box" id="methodology-sd" style="display:none;">
                <h4>Nota Metodol√≥gica (Altura de Nieve) üìù</h4>
                <p>
                    <strong>Promedio Mensual:</strong> Un mes se muestra si contiene > <strong>50%</strong> de d√≠as con datos.
                </p>
                 <p>
                    <strong>M√°ximo Anual:</strong> Se muestra el valor m√°ximo de los promedios mensuales para cada a√±o que tenga al menos <strong>9 meses</strong> v√°lidos.
                </p>
            </div>

            <div class="methodology-box" id="methodology-at" style="display:none;">
                <h4>Nota Metodol√≥gica (Temperatura) üìù</h4>
                <p>
                    <strong>Promedio Mensual:</strong> Un mes se muestra si contiene > <strong>80%</strong> de d√≠as con datos.
                </p>
                 <p>
                    <strong>Extremos Anuales:</strong> Se muestra el valor m√°ximo y m√≠nimo de los promedios mensuales para cada a√±o que tenga al menos <strong>9 meses</strong> v√°lidos.
                </p>
            </div>

        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // --- CONFIGURACI√ìN Y VARIABLES GLOBALES ---
        Plotly.setPlotConfig({locale: 'es'});
        const DATA_STATIC_BASE_URL = 'data_static'; 
        const ZOOM_THRESHOLD = 10;
        let mapa = null;
        let layerControl = null;
        let estacionesLayer = null; 
        let stationNameMap = {}; 
        let cuencasLayer = null;
        let subcuencasLayer = null;
        let subsubcuencasLayer = null;
        let highlightedFeature = null;
        let currentBasinFullData = null;
        let stationColorMap = {};
        let globalGeojsonData = null; 

        let currentVariable = 'ppt'; 
        let currentHierarchy = 'cuencas'; 

        const HIGH_CONTRAST_PALETTE = ['#332288', '#117733', '#44AA99', '#88CCEE', '#DDCC77', '#CC6677', '#AA4499', '#882255', '#E69F00', '#56B4E9', '#009E73', '#F0E442'];
        
        // --- ¬°CONFIGURACI√ìN UI ACTUALIZADA! ---
        const VARIABLE_UI_CONFIG = {
            'ppt': { 
                name: "Precipitaci√≥n", 
                unit: "mm", 
                data_col: "Precipitacion_mm", // Debe coincidir con backend
                agg_monthly_desc: "Acumulado Mensual", 
                annual_analysis_type: 'ppt_robust' // Tipo de an√°lisis anual
            },
            'sd': { 
                name: "Altura de Nieve", 
                unit: "cm", 
                data_col: "Altura_de_Nieve_cm", // Debe coincidir con backend
                agg_monthly_desc: "Promedio Mensual", 
                annual_analysis_type: 'sd_max' // Tipo de an√°lisis anual
            },
            'at': { 
                name: "Temperatura", 
                unit: "C", 
                data_col: "Temperatura_¬∞C", // ¬°NUEVO! Debe coincidir con backend
                agg_monthly_desc: "Promedio Mensual", 
                annual_analysis_type: 'at_stats' // Tipo de an√°lisis anual
            }
        };
        // --- FIN ACTUALIZACI√ìN ---


        const HIERARCHY_CONFIG = {
            'cuencas': { id_property: 'COD_CUEN', name_property: 'NOM_CUEN', name: 'Cuenca' },
            'subcuencas': { id_property: 'COD_SUBC', name_property: 'NOM_SUBC', name: 'Subcuenca' },
            'subsubcuencas': { id_property: 'COD_SSUBC', name_property: 'NOM_SSUBC', name: 'Subsubcuenca' }
        };

        const FUENTES_MAP = { 'DGA': '#007bff', 'CEAZAMET': '#28a745', 'CIEP': '#ffc107', 'CECS': '#dc3545', 'DMC': '#6f42c1', 'CR2': '#fd7e14', 'Otro': '#6c757d' };
        
        window.onload = () => {
            inicializarMapa();
            cargarDatosGeoespaciales();
            switchHierarchyLayer('cuencas');

            document.getElementById('hierarchy-select').addEventListener('change', (e) => switchHierarchyLayer(e.target.value));
            document.getElementById('variable-select').addEventListener('change', (e) => {
                currentVariable = e.target.value; 
                onVariableChange(); 
            });
        };

        function onVariableChange() {
            console.log(`Cambiando a variable: ${currentVariable}`);
            
            // 1. Limpia los gr√°ficos y RESTAURA los mensajes iniciales
            Plotly.purge('chartContainer');
            const chartStatus = document.getElementById('chartStatus');
            if (!chartStatus) {
                document.getElementById('chartContainer').innerHTML = '<p id="chartStatus" style="text-align: center; color: #6c757d; padding: 100px;"></p>';
            }
            document.getElementById('chartStatus').innerText = 'Seleccione una estaci√≥n en el mapa o en el selector...';
            document.getElementById('chartStatus').style.display = 'block'; 
            document.getElementById('yearButtonsContainer').innerHTML = ''; 

            Plotly.purge('basinChartContainer');
            const basinChartStatus = document.getElementById('basinChartStatus');
            if (!basinChartStatus) {
                 document.getElementById('basinChartContainer').innerHTML = '<p id="basinChartStatus" style="text-align: center; color: #6c757d; padding: 100px;"></p>';
            }
            document.getElementById('basinChartStatus').innerText = 'Seleccione un pol√≠gono en el mapa para comparar.';
            document.getElementById('basinChartStatus').style.display = 'block'; 
            document.getElementById('basinYearButtonsContainer').innerHTML = ''; 
            document.getElementById('comparator-title').innerText = 'An√°lisis Comparativo por Cuenca/Subcuenca'; 
            
            // 2. Recarga la capa de pol√≠gonos
            switchHierarchyLayer(currentHierarchy); 

            // 3. Filtra marcadores y dropdown
            filterStationsOnMap();
            filterStationDropdown(); 

            // 4. Actualiza la nota metodol√≥gica
            updateMethodologyBox();
            
            console.log("Paneles reseteados por cambio de variable.");
        }

        function filterStationsOnMap() {
             // ... (sin cambios) ...
             if (!estacionesLayer) return;
            estacionesLayer.eachLayer(layer => {
                const props = layer.feature.properties;
                const variables = (props.variables_disponibles || "").split('|'); 
                
                if (!variables.includes(currentVariable.toUpperCase())) {
                    layer.setStyle({ fillColor: '#999', color: '#999', weight: 0.5, fillOpacity: 0.3 });
                } else {
                    layer.setStyle({ 
                        fillColor: getColorByFuente(props.fuente), 
                        color: "#000", 
                        weight: 1, 
                        fillOpacity: 0.8 
                    });
                }
            });
        }
        
        function filterStationDropdown() {
             // ... (sin cambios) ...
             if (!globalGeojsonData) return; 

            const stationSelect = document.getElementById('station-select');
            const previouslySelected = stationSelect.value; 
            stationSelect.value = ""; 

            let firstVisibleStationCode = null; 

            for (const optgroup of stationSelect.querySelectorAll('optgroup')) {
                let hasVisibleOptions = false;
                for (const option of optgroup.querySelectorAll('option')) {
                    const stationCode = option.value;
                    const feature = globalGeojsonData.features.find(f => f.properties.code_internal === stationCode);
                    
                    if (feature) {
                         const variables = (feature.properties.variables_disponibles || "").split('|');
                         if (variables.includes(currentVariable.toUpperCase())) {
                            option.style.display = 'block'; 
                            hasVisibleOptions = true;
                            if (!firstVisibleStationCode) {
                                firstVisibleStationCode = stationCode; 
                            }
                         } else {
                            option.style.display = 'none'; 
                         }
                    } else {
                         option.style.display = 'none';
                    }
                }
                optgroup.style.display = hasVisibleOptions ? 'block' : 'none';
            }

            const optionToReselect = stationSelect.querySelector(`option[value="${previouslySelected}"]`);
            if (optionToReselect && optionToReselect.style.display !== 'none') {
                stationSelect.value = previouslySelected;
            } else {
                 stationSelect.value = ""; 
            }
        }
        
        // --- ¬°FUNCI√ìN ACTUALIZADA! ---
        function updateMethodologyBox() {
            document.getElementById('methodology-ppt').style.display = 'none';
            document.getElementById('methodology-sd').style.display = 'none';
            document.getElementById('methodology-at').style.display = 'none'; 

            if (currentVariable === 'ppt') {
                document.getElementById('methodology-ppt').style.display = 'block';
            } else if (currentVariable === 'sd') {
                document.getElementById('methodology-sd').style.display = 'block';
            } else if (currentVariable === 'at') { 
                document.getElementById('methodology-at').style.display = 'block';
            }
        }
        // --- FIN ACTUALIZACI√ìN ---


        function inicializarMapa() {
             // ... (sin cambios) ...
             mapa = L.map('mapa').setView([-33.4489, -70.6693], 5);
            mapa.createPane('cuencasPane');
            mapa.getPane('cuencasPane').style.zIndex = 350;

            const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                attribution: '¬© OpenStreetMap contributors' 
            }).addTo(mapa);
            const satelite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                attribution: '¬© Esri' 
            });
            const topografico = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            });

            const baseMaps = {"Calles": osm, "Satelital": satelite, "Topogr√°fico": topografico };
            layerControl = L.control.layers(baseMaps, {}).addTo(mapa);

            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function () {
                const div = L.DomUtil.create('div', 'info legend');
                let legendHtml = '<b>Fuentes</b>';
                const items = Object.keys(FUENTES_MAP).map(key => `<i style="background:${FUENTES_MAP[key]}"></i> ${key}`);
                legendHtml += `<div style="margin-top: 4px;">${items.join('<br>')}</div>`;
                div.innerHTML = legendHtml;
                return div;
            };
            legend.addTo(mapa);
            
            mapa.on('zoomend', updateLayerInteractivity);
        }

        function getColorByFuente(fuente) {
             // ... (sin cambios) ...
             fuente = (fuente || '').toUpperCase().replace(/_NERC/g, ''); 
            return FUENTES_MAP[fuente] || '#6c757d';
        }

        async function cargarDatosGeoespaciales() {
             // ... (sin cambios) ...
             try {
                const [nameResponse, geoResponse] = await Promise.all([
                    fetch(`${DATA_STATIC_BASE_URL}/station_names.json`),
                    fetch(`${DATA_STATIC_BASE_URL}/estaciones.geojson`) 
                ]);
                
                if (!nameResponse.ok) {
                    console.error("¬°ERROR! No se pudo cargar station_names.json. Status:", nameResponse.status);
                    stationNameMap = {}; 
                } else {
                    try {
                        stationNameMap = await nameResponse.json();
                        console.log("station_names.json cargado OK.");
                    } catch (e) {
                         console.error("Error al parsear station_names.json:", e);
                         stationNameMap = {};
                    }
                }

                if (!geoResponse.ok) {
                    console.error("¬°ERROR CR√çTICO! No se encontr√≥ 'estaciones.geojson'. Status:", geoResponse.status);
                    console.error("Por favor, ejecuta el script de backend (exportar_datos_estaticos.py) y aseg√∫rate de que no haya errores.");
                    document.body.innerHTML = "<h1 style='color:red;'>Error Cr√≠tico: Falta estaciones.geojson. Revisa la consola (F12) y ejecuta el backend.</h1>"; 
                    return; 
                }
                globalGeojsonData = await geoResponse.json(); 
                console.log("estaciones.geojson cargado OK.");
                
                if (estacionesLayer) { 
                    mapa.removeLayer(estacionesLayer); 
                    layerControl.removeLayer(estacionesLayer); 
                }

                populateStationDropdown(globalGeojsonData.features);

                estacionesLayer = L.geoJSON(globalGeojsonData, {
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, {radius: 6, fillColor: getColorByFuente(feature.properties.fuente), color: "#000", weight: 1, fillOpacity: 0.8}),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        if (props && props.code_internal) {
                            
                            const variables = props.variables_disponibles || ""; 
                            const vars_display = variables.replace(/\|/g, ', ') || 'N/A'; 

                            const html = `
                                <div style="line-height: 1.5;">
                                    <h4 style="margin: 0 0 5px 0; color:${getColorByFuente(props.fuente)};">${props.name || 'N/A'}</h4>
                                    <b>C√≥digo:</b> ${props.code_internal}<br>
                                    <b>Elevaci√≥n:</b> ${props.elevation || 'N/A'} m.s.n.m.<br>
                                    <b>Fuente:</b> ${props.fuente || 'N/A'}<br>
                                    <b>Variables:</b> ${vars_display}
                                </div>`;
                            layer.bindPopup(html);
                        }
                    }
                }).addTo(mapa);
                
                layerControl.addOverlay(estacionesLayer, "Estaciones");
                const bounds = estacionesLayer.getBounds();
                if (bounds.isValid()) mapa.fitBounds(bounds.pad(0.1));

                updateLayerInteractivity();
                filterStationsOnMap(); 
                filterStationDropdown(); 
            } catch (error) { 
                console.error("Error MUY GRAVE al cargar datos geoespaciales:", error); 
                 document.body.innerHTML = `<h1 style='color:red;'>Error Inesperado: ${error.message}. Revisa la consola (F12).</h1>`;
            }
        }

        function populateStationDropdown(features) {
             // ... (sin cambios) ...
             const stationSelect = document.getElementById('station-select');
            stationSelect.innerHTML = '<option value="" selected disabled>--- Seleccione una Estaci√≥n ---</option>';
            
            const basinData = {};
            features.forEach(feature => {
                const props = feature.properties;
                if (!props.code_internal || !props.basin) return;
                const basinName = props.basin.replace(/\s*\([^)]*\)$/, '');
                const basinCode = String(props.code_internal).substring(0, 3);
                if (!basinData[basinName]) {
                    basinData[basinName] = { name: basinName, code: basinCode, stations: [] };
                }
                basinData[basinName].stations.push(props);
            });

            const sortedBasins = Object.values(basinData).sort((a, b) => parseInt(a.code, 10) - parseInt(b.code, 10));
            sortedBasins.forEach(basin => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${basin.name} (${basin.code})`;
                
                basin.stations.sort((a, b) => {
                    const codeA = parseInt(a.code_internal.replace( /^\D+/g, ''), 10) || a.code_internal;
                    const codeB = parseInt(b.code_internal.replace( /^\D+/g, ''), 10) || b.code_internal;
                    if (isFinite(codeA) && isFinite(codeB)) {
                        return codeA - codeB;
                    }
                    return a.code_internal.localeCompare(b.code_internal);
                });

                basin.stations.forEach(props => {
                    const option = new Option(`${props.name || 'N/A'} (${props.code_internal})`, props.code_internal);
                    optgroup.appendChild(option);
                });
                stationSelect.appendChild(optgroup);
            });
        }

        async function displayTimeSeries(stationCode) {
            // --- ¬°CORRECCI√ìN APLICADA! (L√≠nea style.display eliminada) ---
            if (!stationCode) return;
            const chartDiv = document.getElementById('chartContainer');
            Plotly.purge(chartDiv); 
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando serie temporal para ${stationCode}...</p>`; 
            document.getElementById('station-select').value = stationCode;
            
            const csvUrl = `${DATA_STATIC_BASE_URL}/${stationCode}_${currentVariable}.csv`;
            console.log("Intentando cargar CSV:", csvUrl); 

            try {
                const response = await fetch(csvUrl);
                
                if (!response.ok) {
                    console.error(`Error ${response.status} al cargar ${csvUrl}`); 
                    if (response.status === 404) {
                        const config = VARIABLE_UI_CONFIG[currentVariable];
                        throw new Error(`Datos de '${config.name}' no disponibles para la estaci√≥n ${stationCode}.`);
                    }
                    throw new Error(`No se pudo cargar el CSV ${stationCode} (c√≥digo ${response.status})`);
                }
                console.log(`CSV ${csvUrl} cargado OK.`); 

                const csvText = await response.text();
                const parseResult = Papa.parse(csvText, {header: true, dynamicTyping: true, skipEmptyLines: true});
                const data = parseResult.data;
                
                if (parseResult.errors.length > 0) { console.warn(`Errores de PapaParse para ${csvUrl}:`, parseResult.errors); }
                if (data.length === 0) { console.warn(`PapaParse no encontr√≥ datos en ${csvUrl}.`); throw new Error(`No se encontraron datos en el archivo CSV para ${stationCode}.`); }
                 
                const stationName = stationNameMap[stationCode] || stationCode; 
                 if (!stationNameMap[stationCode]) { console.warn(`No se encontr√≥ el nombre para ${stationCode}.`); }

                const years = [...new Set(data.map(d => parseInt(d.Fecha.substring(0, 4), 10)))].sort((a,b) => a-b); // Asegura orden num√©rico
                const container = document.getElementById("yearButtonsContainer");
                container.innerHTML = "";

                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderPlot(data, stationName, null, allBtn);
                container.appendChild(allBtn);

                years.forEach(y => {
                    const btn = document.createElement("button");
                    btn.textContent = y;
                    btn.onclick = () => renderPlot(data.filter(d => parseInt(d.Fecha.substring(0, 4), 10) === y), stationName, y, btn);
                    container.appendChild(btn);
                });
                renderPlot(data, stationName, null, allBtn);
            } catch (error) { 
                console.error("Error en displayTimeSeries:", error); 
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; 
            }
        }
                
        // --- ¬°FUNCI√ìN ACTUALIZADA! ---
        function renderPlot(data, stationName, year, activeBtn) {
            document.querySelectorAll("#yearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");
            
            const config = VARIABLE_UI_CONFIG[currentVariable];
            const dataColumnName = config.data_col; 
            
            if (data.length > 0 && !(dataColumnName in data[0])) {
                 console.error(`Columna '${dataColumnName}' no encontrada. Disponibles:`, Object.keys(data[0]));
                 document.getElementById('chartContainer').innerHTML = `<p style="text-align:center;color:red;padding:50px;">Error: Columna '${dataColumnName}' no encontrada.</p>`;
                 return; 
            }

            let trace = {
                x: data.map(d => d.Fecha), 
                y: data.map(d => {
                    let v = d[dataColumnName]; 
                    if(typeof v === 'string') v = parseFloat(v.trim().replace(',', '.')); 
                    return isFinite(v) ? v : null; 
                })
            };

            // Define tipo y color seg√∫n la variable
            if (currentVariable === 'sd') { // Nieve
                 trace.type = 'scatter';
                 trace.mode = 'lines+markers'; 
                 trace.line = { color: "#88CCEE" }; // Azul claro (cyan)
                 trace.marker = { color: "#88CCEE", size: 4 }; 
            } else if (currentVariable === 'at') { // Temperatura
                trace.type = 'scatter';
                 trace.mode = 'lines+markers'; 
                 trace.line = { color: "#CC6677" }; // Rojo coral
                 trace.marker = { color: "#CC6677", size: 4 };
            } else { // Precipitaci√≥n (default)
                 trace.type = 'bar';
                 trace.marker = { color: "#007bff" }; // Azul
            }
            
            const layout = {
                title: `${config.name} diaria - ${stationName}${year ? ` (${year})` : ""}`,
                margin: { l: 50, r: 50, t: 60, b: 50 }, 
                xaxis: { title: "Fecha", rangeslider: {visible: false} },
                yaxis: { title: `${config.name} (${config.unit})` }, 
                hovermode: "x unified", 
            };

            Plotly.react("chartContainer", [trace], layout, {responsive: true});
             console.log(`Gr√°fico renderizado para ${stationName} (${year || 'Completo'}) - Tipo: ${trace.type}`); 
        }
        // --- FIN ACTUALIZACI√ìN ---


        async function switchHierarchyLayer(hierarchyKey) {
             // ... (sin cambios, mantiene correcci√≥n y logs) ...
             currentHierarchy = hierarchyKey; 
            console.log(`Cambiando a jerarqu√≠a: ${hierarchyKey}`); 
            
            let removedCuencas = false, removedSub = false, removedSubSub = false;
            if (cuencasLayer) { try { mapa.removeLayer(cuencasLayer); layerControl.removeLayer(cuencasLayer); removedCuencas = true; } catch(e) { console.warn("Error quitando cuencasLayer:", e); } }
            if (subcuencasLayer) { try { mapa.removeLayer(subcuencasLayer); layerControl.removeLayer(subcuencasLayer); removedSub = true; } catch(e) { console.warn("Error quitando subcuencasLayer:", e); } }
            if (subsubcuencasLayer) { try { mapa.removeLayer(subsubcuencasLayer); layerControl.removeLayer(subsubcuencasLayer); removedSubSub = true; } catch(e) { console.warn("Error quitando subsubcuencasLayer:", e); } }
            console.log(`Capas antiguas removidas: Cuencas=${removedCuencas}, Sub=${removedSub}, SubSub=${removedSubSub}`);
            
            highlightedFeature = null; 

            const config = HIERARCHY_CONFIG[hierarchyKey];
            if (!config) return;

             const url = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${currentVariable}.geojson`;
             console.log("Intentando cargar GeoJSON de jerarqu√≠a:", url); 

            try {
                const response = await fetch(url);

                if (!response.ok) {
                    console.error(`No se pudo cargar ${url}. Status: ${response.status}. ¬øEjecutaste el backend correctamente?`);
                    throw new Error(`No se pudo cargar ${url}.`);
                }
                console.log(`GeoJSON ${url} cargado OK.`); 

                const geojsonData = await response.json();
                const style = { color: "#1a5276", weight: 1.5, opacity: 0.6, fillOpacity: 0.2 };
                const highlightStyle = { weight: 3, color: '#e74c3c', fillOpacity: 0.4 };

                let newLayer = L.geoJSON(geojsonData, { 
                    style: style,
                    pane: 'cuencasPane',
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const nEstaciones = props.n_estaciones || 0; 
                        const popupContent = `
                            <div style="line-height: 1.5;">
                                <h4 style="margin: 0 0 5px 0; color:#1a5276;">${config.name}: ${props[config.name_property] || 'N/A'}</h4>
                                <b>C√≥digo:</b> ${props[config.id_property]}<br>
                                <b>N¬∞ de estaciones:</b> ${nEstaciones}
                            </div>`;
                        layer.bindPopup(popupContent);
                        layer.on({
                            click: e => {
                                console.log(`Clic en pol√≠gono ${props[config.id_property]}. HighlightedFeature:`, highlightedFeature ? 'existe' : 'null'); 
                                if (highlightedFeature) {
                                    try {
                                        newLayer.resetStyle(highlightedFeature); 
                                        console.log("Estilo reseteado para pol√≠gono anterior."); 
                                    } catch(err) {
                                        console.warn("No se pudo resetear el estilo del pol√≠gono anterior (puede ser normal si cambi√≥ la capa):", err);
                                    }
                                }
                                highlightedFeature = e.target; 
                                e.target.setStyle(highlightStyle);
                                console.log("Nuevo pol√≠gono resaltado:", highlightedFeature); 
                                
                                displayBasinChart(props[config.id_property], props[config.name_property] || '', hierarchyKey);
                                
                                const comparatorSection = document.querySelector('.basin-comparator-section');
                                comparatorSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        });
                    }
                }).addTo(mapa);
                
                let layerName = "Capa";
                if (hierarchyKey === 'cuencas') { cuencasLayer = newLayer; layerName = "Cuencas"; }
                else if (hierarchyKey === 'subcuencas') { subcuencasLayer = newLayer; layerName = "Subcuencas"; }
                else { subsubcuencasLayer = newLayer; layerName = "Subsubcuencas"; }
                
                layerControl.addOverlay(newLayer, layerName);
                updateLayerInteractivity();
                console.log(`Capa ${layerName} (${currentVariable}) a√±adida al mapa.`); 

            } catch (error) { console.error(`Error FATAL en switchHierarchyLayer (${hierarchyKey}, ${currentVariable}):`, error); }
        }

        function updateLayerInteractivity() {
             // ... (sin cambios) ...
             if (!mapa) return;
            const zoom = mapa.getZoom();

            let activeHierarchyLayer;
            if (currentHierarchy === 'cuencas') activeHierarchyLayer = cuencasLayer;
            else if (currentHierarchy === 'subcuencas') activeHierarchyLayer = subcuencasLayer;
            else activeHierarchyLayer = subsubcuencasLayer;
            if (activeHierarchyLayer) {
                activeHierarchyLayer.eachLayer(layer => {
                    if (zoom < ZOOM_THRESHOLD) {
                        if (!layer.listens('mouseover')) {
                            layer.on({
                                mouseover: function (e) { this.openPopup(e.latlng); },
                                mouseout: function () { this.closePopup(); },
                                mousemove: function (e) { if (this.isPopupOpen()) this.getPopup().setLatLng(e.latlng); }
                            });
                        }
                    } else {
                        layer.off('mouseover mouseout mousemove');
                        layer.closePopup();
                    }
                });
            }

            if (estacionesLayer) {
                estacionesLayer.eachLayer(layer => {
                    const props = layer.feature.properties;
                    const variables = (props.variables_disponibles || "").split('|');
                    const hasData = variables.includes(currentVariable.toUpperCase());

                    if (zoom < ZOOM_THRESHOLD) {
                        layer.setRadius(3);
                        layer.off('mouseover mouseout click');
                    } else {
                        layer.setRadius(6);
                        if (hasData) {
                            if (!layer.listens('click')) { 
                                layer.on({
                                    mouseover: function () { this.openPopup(); },
                                    mouseout: function () { this.closePopup(); },
                                    click: () => { displayTimeSeries(props.code_internal); } 
                                });
                            }
                        } else {
                             if (layer.listens('click')) { 
                                 layer.off('mouseover mouseout click');
                             }
                        }
                    }
                });
            } else {
                 console.warn("updateLayerInteractivity: estacionesLayer no existe todav√≠a."); 
            }
        }

        // --- ¬°FUNCI√ìN ACTUALIZADA! ---
        async function displayBasinChart(featureId, featureName, hierarchyKey) {
            const chartDiv = document.getElementById('basinChartContainer');
            const buttonContainer = document.getElementById('basinYearButtonsContainer');
            Plotly.purge(chartDiv); 
            buttonContainer.innerHTML = '';
            // No intentes ocultar #basinChartStatus

            const hierarchyConfig = HIERARCHY_CONFIG[hierarchyKey];
            const locationTitle = `${hierarchyConfig.name} ${featureName} (${featureId})`;
            document.getElementById('comparator-title').innerText = `An√°lisis Comparativo para ${locationTitle}`;
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de ${locationTitle}...</p>`;

            const jsonUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_${currentVariable}.json`;
            console.log("Intentando cargar JSON de cuenca:", jsonUrl); 

            try {
                const response = await fetch(jsonUrl);
                
                if (!response.ok) {
                    console.error(`Error ${response.status} al cargar ${jsonUrl}`); 
                    throw new Error(`No se encontraron datos para ${locationTitle} (Variable: ${currentVariable}).`);
                 }
                 
                currentBasinFullData = await response.json(); 

                if (!currentBasinFullData || typeof currentBasinFullData !== 'object' || Object.keys(currentBasinFullData).length === 0) {
                     console.warn(`Los datos JSON para ${featureId} (${currentVariable}) est√°n vac√≠os o son inv√°lidos.`);
                     throw new Error(`No hay datos v√°lidos para mostrar para ${locationTitle} (Variable: ${currentVariable}).`);
                }
                console.log(`JSON ${jsonUrl} cargado OK y contiene datos.`); 

                stationColorMap = {};
                Object.keys(currentBasinFullData).forEach((stationCode, i) => { 
                    stationColorMap[stationCode] = HIGH_CONTRAST_PALETTE[i % HIGH_CONTRAST_PALETTE.length];
                });
                
                const allDates = Object.values(currentBasinFullData).flatMap(s => s.dates);
                if (allDates.length === 0) {
                     console.warn(`No se encontraron fechas en los datos JSON para ${featureId}.`);
                     renderBasinPlot({}, null, null); 
                     return;
                }
                const years = [...new Set(allDates.map(d => parseInt(d.substring(0, 4), 10)))].sort((a,b)=>a-b);

                // --- Botones de A√±o ---
                const allBtn = document.createElement("button");
                allBtn.textContent = "Serie Completa";
                allBtn.classList.add("active");
                allBtn.onclick = () => renderBasinPlot(currentBasinFullData, null, allBtn);
                buttonContainer.appendChild(allBtn);

                years.forEach(year => {
                    const btn = document.createElement("button");
                    btn.textContent = year;
                    btn.onclick = () => { /* ... (l√≥gica de filtro sin cambios) ... */ 
                        const filteredData = {};
                        for (const stationCode in currentBasinFullData) {
                            const station = currentBasinFullData[stationCode];
                            const filteredDates = [], filteredValues = [];
                            let hasNonNullData = false;
                            station.dates.forEach((date, i) => {
                                if (parseInt(date.substring(0, 4), 10) === year) {
                                    filteredDates.push(date); filteredValues.push(station.values[i]);
                                    if (station.values[i] !== null) hasNonNullData = true;
                                }
                            });
                            if (hasNonNullData) { filteredData[stationCode] = { ...station, dates: filteredDates, values: filteredValues }; }
                        }
                        renderBasinPlot(filteredData, year, btn);
                    };
                    buttonContainer.appendChild(btn);
                });
                // --- Fin Botones de A√±o ---

                // --- BOT√ìN DE AN√ÅLISIS ANUAL (DIN√ÅMICO) ---
                const annualConfig = VARIABLE_UI_CONFIG[currentVariable];
                const analysisType = annualConfig.annual_analysis_type;

                if (analysisType) { // Si hay alg√∫n tipo de an√°lisis anual definido
                     const annualBtn = document.createElement("button");
                     let buttonText = "An√°lisis Anual"; // Texto por defecto
                     let clickHandler = null;

                     if (analysisType === 'ppt_robust') {
                          buttonText = "Acumulaci√≥n Anual";
                          clickHandler = () => renderBasinAnnualPlot(featureId, hierarchyKey, annualBtn);
                     } else if (analysisType === 'sd_max') {
                          buttonText = "M√°ximo Anual";
                          clickHandler = () => renderBasinAnnualMaxPlot(featureId, hierarchyKey, annualBtn);
                     } else if (analysisType === 'at_stats') {
                          buttonText = "Extremos Anuales";
                          clickHandler = () => renderBasinAnnualStatsPlot(featureId, hierarchyKey, annualBtn);
                     }
                     
                     if(clickHandler) {
                         annualBtn.textContent = buttonText;
                         annualBtn.onclick = clickHandler;
                         buttonContainer.appendChild(annualBtn);
                     }
                }
                // --- FIN BOT√ìN AN√ÅLISIS ANUAL ---
                
                renderBasinPlot(currentBasinFullData, null, allBtn); // Muestra el gr√°fico mensual por defecto
            } catch (error) {
                console.error("Error en displayBasinChart:", error); 
                chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`;
                currentBasinFullData = null;
            }
        }
        // --- FIN ACTUALIZACI√ìN ---


        function renderBasinPlot(dataToPlot, year, activeBtn) {
             // ... (sin cambios) ...
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

             if (Object.keys(dataToPlot).length === 0) {
                 console.log("renderBasinPlot: No hay datos para graficar.");
                 Plotly.newPlot('basinChartContainer', [], {title: `No hay datos disponibles${year ? ` (${year})` : ''}`});
                 return;
             }

            const sortedStations = Object.entries(dataToPlot).sort(([, stationA], [, stationB]) => {
                const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                return elevB - elevA;
            });

            const config = VARIABLE_UI_CONFIG[currentVariable];
            const yAxisTitle = `${config.name} (${config.unit})`;
            const plotTitle = `${config.agg_monthly_desc} de ${config.name}${year ? ` (${year})` : ''}`;
            const hoverUnit = config.unit;

            const traces = sortedStations.map(([stationCode, station]) => {
                const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                return { 
                    x: station.dates, 
                    y: station.values, 
                    mode: 'lines+markers', 
                    name: `${station.name} (${elevationText})`, 
                    type: 'scatter',
                    line: { color: stationColorMap[stationCode] || '#ccc' }, 
                    marker: { color: stationColorMap[stationCode] || '#ccc'},
                    hovertemplate: `<b>${station.name}</b><br>%{x|%B de %Y}<br>${config.name}: %{y:.1f} ${hoverUnit}<extra></extra>`, 
                };
            });

            const xAxisConfig = { title: 'Fecha' };
            if (year) {
                xAxisConfig.range = [`${year}-01-01`, `${year}-12-31`];
                xAxisConfig.tickformat = '%B';
            }

            const layout = {
                title: plotTitle, 
                xaxis: xAxisConfig,
                yaxis: { title: yAxisTitle }, 
                hovermode: 'closest',
                showlegend: true,
                legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                margin: { r: 250 }
            };
            
            Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
             console.log(`Gr√°fico de cuenca renderizado (${year || 'Completo'})`); 
        }
        
        async function renderBasinAnnualPlot(featureId, hierarchyKey, activeBtn) {
             // ... (sin cambios, espec√≠fica para PPT) ...
             document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando datos de acumulaci√≥n anual...</p>`;

            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_${currentVariable}_annual.json`; // _ppt_annual.json
            console.log("Intentando cargar JSON anual PPT:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de acumulaci√≥n anual.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualPlot: No hay datos anuales PPT."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos anuales disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const config = VARIABLE_UI_CONFIG[currentVariable]; // Ser√° PPT aqu√≠
                const yAxisTitle = `Acumulado Anual (${config.unit})`;
                const hoverUnit = config.unit;
                const hoverName = config.name;

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years, y: station.values, name: `${station.name} (${elevationText})`,
                        type: 'scatter', mode: 'lines+markers',
                        line: { color: stationColorMap[stationCode] || '#333' }, marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A√±o: %{x}<br>${hoverName}: %{y:.1f} ${hoverUnit}<extra></extra>`,
                    };
                });

                const layout = {
                    title: 'Precipitaci√≥n Acumulada Anual (A√±os V√°lidos)',
                    xaxis: { title: 'A√±o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest',
                    legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log("Gr√°fico anual PPT renderizado."); 

            } catch (error) { console.error("Error en renderBasinAnnualPlot:", error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }

        // --- ¬°NUEVA FUNCI√ìN para SD Max Anual! ---
        async function renderBasinAnnualMaxPlot(featureId, hierarchyKey, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando m√°ximos anuales de nieve...</p>`;

            // Construye la URL del nuevo archivo JSON
            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_sd_annual_max.json`; 
            console.log("Intentando cargar JSON anual SD Max:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de m√°ximo anual de nieve.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualMaxPlot: No hay datos anuales SD max."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos de m√°ximo anual de nieve disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const config = VARIABLE_UI_CONFIG['sd']; // Usa config de SD
                const yAxisTitle = `M√°ximo Mensual Anual (${config.unit})`;
                const hoverUnit = config.unit;
                const hoverName = config.name;

                const traces = sortedStations.map(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    return {
                        x: station.years, 
                        y: station.values, // 'values' contiene los m√°ximos anuales
                        name: `${station.name} (${elevationText})`,
                        type: 'scatter', mode: 'lines+markers',
                        line: { color: stationColorMap[stationCode] || '#333' }, 
                        marker: { color: stationColorMap[stationCode] || '#333' },
                        hovertemplate: `<b>${station.name}</b><br>A√±o: %{x}<br>M√°x. ${hoverName}: %{y:.1f} ${hoverUnit}<extra></extra>`, // Texto hover ajustado
                    };
                });

                const layout = {
                    title: 'Altura de Nieve M√°xima Mensual por A√±o (A√±os V√°lidos)', // T√≠tulo ajustado
                    xaxis: { title: 'A√±o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest',
                    legend: { traceorder: 'normal', title: { text: '<b>Estaciones</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log("Gr√°fico anual SD Max renderizado."); 

            } catch (error) { console.error("Error en renderBasinAnnualMaxPlot:", error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }

        // --- ¬°NUEVA FUNCI√ìN para AT Max/Min Anual! ---
        async function renderBasinAnnualStatsPlot(featureId, hierarchyKey, activeBtn) {
            document.querySelectorAll("#basinYearButtonsContainer button").forEach(b => b.classList.remove("active"));
            if (activeBtn) activeBtn.classList.add("active");

            const chartDiv = document.getElementById('basinChartContainer');
            chartDiv.innerHTML = `<p style="text-align:center;color:#007bff;padding:100px;">Cargando extremos anuales de temperatura...</p>`;

            // Construye la URL del nuevo archivo JSON
            const annualUrl = `${DATA_STATIC_BASE_URL}/${hierarchyKey}_${featureId}_at_annual_stats.json`; 
            console.log("Intentando cargar JSON anual AT Stats:", annualUrl); 

            try {
                const response = await fetch(annualUrl);
                if (!response.ok) { console.error(`Error ${response.status} al cargar ${annualUrl}`); throw new Error(`No se encontraron datos de extremos anuales de temperatura.`); }
                 console.log(`JSON anual ${annualUrl} cargado OK.`); 
                const annualData = await response.json();

                 if (Object.keys(annualData).length === 0) { console.warn("renderBasinAnnualStatsPlot: No hay datos anuales AT stats."); Plotly.newPlot('basinChartContainer', [], {title: 'No hay datos de extremos anuales de temperatura disponibles'}); return; }

                const sortedStations = Object.entries(annualData).sort(([, stationA], [, stationB]) => {
                    const elevA = stationA.elevation === null ? -Infinity : stationA.elevation;
                    const elevB = stationB.elevation === null ? -Infinity : stationB.elevation;
                    return elevB - elevA;
                });

                const config = VARIABLE_UI_CONFIG['at']; // Usa config de AT
                const yAxisTitle = `Temperatura (${config.unit})`;
                const hoverUnit = config.unit;

                const traces = []; // Array para acumular todas las trazas (max y min)

                sortedStations.forEach(([stationCode, station]) => {
                    const elevationText = station.elevation !== null ? `${station.elevation} msnm` : 'N/A';
                    const stationColor = stationColorMap[stationCode] || '#333'; // Color base

                    // Traza para M√°ximos (tri√°ngulo hacia arriba)
                    traces.push({
                        x: station.years, 
                        y: station.max_values, // Usa max_values
                        name: `${station.name} (${elevationText}) - M√°x`, // Leyenda indica M√°x
                        legendgroup: stationCode, // Agrupa leyenda de max y min
                        type: 'scatter', mode: 'lines+markers',
                        line: { color: stationColor }, // Mismo color
                        marker: { 
                            color: stationColor, 
                            symbol: 'triangle-up', // S√≠mbolo Max
                            size: 7
                        }, 
                        hovertemplate: `<b>${station.name}</b><br>A√±o: %{x}<br>Temp. M√°x: %{y:.1f} ${hoverUnit}<extra></extra>`,
                    });

                     // Traza para M√≠nimos (tri√°ngulo hacia abajo)
                    traces.push({
                        x: station.years, 
                        y: station.min_values, // Usa min_values
                        name: `${station.name} (${elevationText}) - M√≠n`, // Leyenda indica M√≠n
                        legendgroup: stationCode, // Agrupa leyenda
                        showlegend: false, // Opcional: Oculta la segunda entrada de leyenda para limpieza
                        type: 'scatter', mode: 'lines+markers',
                        line: { color: stationColor, dash: 'dot' }, // Mismo color, l√≠nea punteada opcional
                        marker: { 
                            color: stationColor, 
                            symbol: 'triangle-down', // S√≠mbolo Min
                            size: 7 
                        }, 
                        hovertemplate: `<b>${station.name}</b><br>A√±o: %{x}<br>Temp. M√≠n: %{y:.1f} ${hoverUnit}<extra></extra>`,
                    });
                });

                const layout = {
                    title: 'Temperatura M√°xima y M√≠nima Mensual por A√±o (A√±os V√°lidos)', // T√≠tulo ajustado
                    xaxis: { title: 'A√±o', type: 'category' }, yaxis: { title: yAxisTitle }, 
                    hovermode: 'closest', // 'closest' funciona mejor con m√∫ltiples trazas
                    legend: { traceorder: 'grouped', title: { text: '<b>Estaciones (M√°x/M√≠n)</b><br> ', font: { size: 14 } }, bgcolor: 'rgba(248, 249, 250, 0.95)', bordercolor: '#dee2e6', borderwidth: 1, borderRadius: 8, x: 1.02, xanchor: 'left' },
                    margin: { r: 250 }
                };
                Plotly.newPlot('basinChartContainer', traces, layout, {responsive: true});
                 console.log("Gr√°fico anual AT Stats renderizado."); 

            } catch (error) { console.error("Error en renderBasinAnnualStatsPlot:", error); chartDiv.innerHTML = `<p style="text-align:center;color:#dc3545;padding:100px;">${error.message}</p>`; }
        }
        // --- FIN NUEVAS FUNCIONES ---

    </script>
</body>
</html>